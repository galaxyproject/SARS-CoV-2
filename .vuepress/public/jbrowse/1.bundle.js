(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	// "/Users/yoplait/work/jbrowse/node_modules/dojo-webpack-plugin/lib/NoModule.js" = "./node_modules/dojo-webpack-plugin/lib/NoModule.js"
	"dojo/Deferred":"./node_modules/dojo/Deferred.js",
	"dojo/Evented":"./node_modules/dojo/Evented.js",
	"dojo/aspect":"./node_modules/dojo/aspect.js",
	"dojo/errors/CancelError":"./node_modules/dojo/errors/CancelError.js",
	"dojo/errors/create":"./node_modules/dojo/errors/create.js",
	"dojo/on":"./node_modules/dojo/on.js",
	"dojo/promise/Promise":"./node_modules/dojo/promise/Promise.js",
	"dojo/promise/instrumentation":"./node_modules/dojo/promise/instrumentation.js",
	"dojo/promise/tracer":"./node_modules/dojo/promise/tracer.js",
	"dojox/lang/functional/fold":"./node_modules/dojox/lang/functional/fold.js",
	"dojox/lang/functional/lambda":"./node_modules/dojox/lang/functional/lambda.js",
	"dojox/lang/functional/object":"./node_modules/dojox/lang/functional/object.js",
	"dojox/main":"./node_modules/dojox/main.js",
	"punycode":"./node_modules/punycode/punycode.js"
	// "./decode" = "./node_modules/querystring-es3/decode.js"
	// "./encode" = "./node_modules/querystring-es3/encode.js"
	// "querystring" = "./node_modules/querystring-es3/index.js"
	// "url" = "./node_modules/url/url.js"
	// "./util" = "./node_modules/url/util.js"
	// "./../webpack/buildin/module.js" = "./node_modules/webpack/buildin/module.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/dojo-webpack-plugin/lib/NoModule.js":
/*!**********************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/lib/NoModule.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n * (C) Copyright IBM Corp. 2012, 2016 All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nmodule.exports = undefined;\r\n\n\n//# sourceURL=webpack:///./node_modules/dojo-webpack-plugin/lib/NoModule.js?");

/***/ }),

/***/ "./node_modules/dojo/Deferred.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/Deferred.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t__webpack_require__(/*! ./has */ \"./node_modules/dojo/has.js\"),\n\t__webpack_require__(/*! ./_base/lang */ \"./node_modules/dojo/_base/lang.js\"),\n\t__webpack_require__(/*! ./errors/CancelError */ \"./node_modules/dojo/errors/CancelError.js\"),\n\t__webpack_require__(/*! ./promise/Promise */ \"./node_modules/dojo/promise/Promise.js\"),\n\t__webpack_require__(/*! ./promise/instrumentation */ \"./node_modules/dojo/promise/instrumentation.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, lang, CancelError, Promise, instrumentation){\n\t\"use strict\";\n\n\t// module:\n\t//\t\tdojo/Deferred\n\n\tvar PROGRESS = 0,\n\t\t\tRESOLVED = 1,\n\t\t\tREJECTED = 2;\n\tvar FULFILLED_ERROR_MESSAGE = \"This deferred has already been fulfilled.\";\n\n\tvar freezeObject = Object.freeze || function(){};\n\n\tvar signalWaiting = function(waiting, type, result, rejection, deferred){\n\t\tif(has(\"config-deferredInstrumentation\")){\n\t\t\tif(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){\n\t\t\t\tDeferred.instrumentRejected(result, false, rejection, deferred);\n\t\t\t}\n\t\t}\n\n\t\tfor(var i = 0; i < waiting.length; i++){\n\t\t\tsignalListener(waiting[i], type, result, rejection);\n\t\t}\n\t};\n\n\tvar signalListener = function(listener, type, result, rejection){\n\t\tvar func = listener[type];\n\t\tvar deferred = listener.deferred;\n\t\tif(func){\n\t\t\ttry{\n\t\t\t\tvar newResult = func(result);\n\t\t\t\tif(type === PROGRESS){\n\t\t\t\t\tif(typeof newResult !== \"undefined\"){\n\t\t\t\t\t\tsignalDeferred(deferred, type, newResult);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(newResult && typeof newResult.then === \"function\"){\n\t\t\t\t\t\tlistener.cancel = newResult.cancel;\n\t\t\t\t\t\tnewResult.then(\n\t\t\t\t\t\t\t\t// Only make resolvers if they're actually going to be used\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, RESOLVED),\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, REJECTED),\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, PROGRESS));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsignalDeferred(deferred, RESOLVED, newResult);\n\t\t\t\t}\n\t\t\t}catch(error){\n\t\t\t\tsignalDeferred(deferred, REJECTED, error);\n\t\t\t}\n\t\t}else{\n\t\t\tsignalDeferred(deferred, type, result);\n\t\t}\n\n\t\tif(has(\"config-deferredInstrumentation\")){\n\t\t\tif(type === REJECTED && Deferred.instrumentRejected){\n\t\t\t\tDeferred.instrumentRejected(result, !!func, rejection, deferred.promise);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar makeDeferredSignaler = function(deferred, type){\n\t\treturn function(value){\n\t\t\tsignalDeferred(deferred, type, value);\n\t\t};\n\t};\n\n\tvar signalDeferred = function(deferred, type, result){\n\t\tif(!deferred.isCanceled()){\n\t\t\tswitch(type){\n\t\t\t\tcase PROGRESS:\n\t\t\t\t\tdeferred.progress(result);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RESOLVED:\n\t\t\t\t\tdeferred.resolve(result);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REJECTED:\n\t\t\t\t\tdeferred.reject(result);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar Deferred = function(canceler){\n\t\t// summary:\n\t\t//\t\tCreates a new deferred. This API is preferred over\n\t\t//\t\t`dojo/_base/Deferred`.\n\t\t// description:\n\t\t//\t\tCreates a new deferred, as an abstraction over (primarily)\n\t\t//\t\tasynchronous operations. The deferred is the private interface\n\t\t//\t\tthat should not be returned to calling code. That's what the\n\t\t//\t\t`promise` is for. See `dojo/promise/Promise`.\n\t\t// canceler: Function?\n\t\t//\t\tWill be invoked if the deferred is canceled. The canceler\n\t\t//\t\treceives the reason the deferred was canceled as its argument.\n\t\t//\t\tThe deferred is rejected with its return value, or a new\n\t\t//\t\t`dojo/errors/CancelError` instance.\n\n\t\t// promise: dojo/promise/Promise\n\t\t//\t\tThe public promise object that clients can add callbacks to. \n\t\tvar promise = this.promise = new Promise();\n\n\t\tvar deferred = this;\n\t\tvar fulfilled, result, rejection;\n\t\tvar canceled = false;\n\t\tvar waiting = [];\n\n\t\tif(has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\n\t\t\tError.captureStackTrace(deferred, Deferred);\n\t\t\tError.captureStackTrace(promise, Deferred);\n\t\t}\n\n\t\tthis.isResolved = promise.isResolved = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been resolved.\n\t\t\t// returns: Boolean\n\n\t\t\treturn fulfilled === RESOLVED;\n\t\t};\n\n\t\tthis.isRejected = promise.isRejected = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been rejected.\n\t\t\t// returns: Boolean\n\n\t\t\treturn fulfilled === REJECTED;\n\t\t};\n\n\t\tthis.isFulfilled = promise.isFulfilled = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been resolved or rejected.\n\t\t\t// returns: Boolean\n\n\t\t\treturn !!fulfilled;\n\t\t};\n\n\t\tthis.isCanceled = promise.isCanceled = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been canceled.\n\t\t\t// returns: Boolean\n\n\t\t\treturn canceled;\n\t\t};\n\n\t\tthis.progress = function(update, strict){\n\t\t\t// summary:\n\t\t\t//\t\tEmit a progress update on the deferred.\n\t\t\t// description:\n\t\t\t//\t\tEmit a progress update on the deferred. Progress updates\n\t\t\t//\t\tcan be used to communicate updates about the asynchronous\n\t\t\t//\t\toperation before it has finished.\n\t\t\t// update: any\n\t\t\t//\t\tThe progress update. Passed to progbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently no progress can be emitted.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\tsignalWaiting(waiting, PROGRESS, update, null, deferred);\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tthis.resolve = function(value, strict){\n\t\t\t// summary:\n\t\t\t//\t\tResolve the deferred.\n\t\t\t// description:\n\t\t\t//\t\tResolve the deferred, putting it in a success state.\n\t\t\t// value: any\n\t\t\t//\t\tThe result of the deferred. Passed to callbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be resolved.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\t// Set fulfilled, store value. After signaling waiting listeners unset\n\t\t\t\t// waiting.\n\t\t\t\tsignalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);\n\t\t\t\twaiting = null;\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tvar reject = this.reject = function(error, strict){\n\t\t\t// summary:\n\t\t\t//\t\tReject the deferred.\n\t\t\t// description:\n\t\t\t//\t\tReject the deferred, putting it in an error state.\n\t\t\t// error: any\n\t\t\t//\t\tThe error result of the deferred. Passed to errbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be rejected.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\tif(has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\n\t\t\t\t\tError.captureStackTrace(rejection = {}, reject);\n\t\t\t\t}\n\t\t\t\tsignalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);\n\t\t\t\twaiting = null;\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tthis.then = promise.then = function(callback, errback, progback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd new callbacks to the deferred.\n\t\t\t// description:\n\t\t\t//\t\tAdd new callbacks to the deferred. Callbacks can be added\n\t\t\t//\t\tbefore or after the deferred is fulfilled.\n\t\t\t// callback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is resolved.\n\t\t\t//\t\tReceives the resolution value.\n\t\t\t// errback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is rejected.\n\t\t\t//\t\tReceives the rejection error.\n\t\t\t// progback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise emits a progress\n\t\t\t//\t\tupdate. Receives the progress update.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the callback(s).\n\t\t\t//\t\tThis can be used for chaining many asynchronous operations.\n\n\t\t\tvar listener = [progback, callback, errback];\n\t\t\t// Ensure we cancel the promise we're waiting for, or if callback/errback\n\t\t\t// have returned a promise, cancel that one.\n\t\t\tlistener.cancel = promise.cancel;\n\t\t\tlistener.deferred = new Deferred(function(reason){\n\t\t\t\t// Check whether cancel is really available, returned promises are not\n\t\t\t\t// required to expose `cancel`\n\t\t\t\treturn listener.cancel && listener.cancel(reason);\n\t\t\t});\n\t\t\tif(fulfilled && !waiting){\n\t\t\t\tsignalListener(listener, fulfilled, result, rejection);\n\t\t\t}else{\n\t\t\t\twaiting.push(listener);\n\t\t\t}\n\t\t\treturn listener.deferred.promise;\n\t\t};\n\n\t\tthis.cancel = promise.cancel = function(reason, strict){\n\t\t\t// summary:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t// description:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t//\t\tThe deferred's (optional) canceler is invoked and the\n\t\t\t//\t\tdeferred will be left in a rejected state. Can affect other\n\t\t\t//\t\tpromises that originate with the same deferred.\n\t\t\t// reason: any\n\t\t\t//\t\tA message that may be sent to the deferred's canceler,\n\t\t\t//\t\texplaining why it's being canceled.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be canceled.\n\t\t\t// returns: any\n\t\t\t//\t\tReturns the rejection reason if the deferred was canceled\n\t\t\t//\t\tnormally.\n\n\t\t\tif(!fulfilled){\n\t\t\t\t// Cancel can be called even after the deferred is fulfilled\n\t\t\t\tif(canceler){\n\t\t\t\t\tvar returnedReason = canceler(reason);\n\t\t\t\t\treason = typeof returnedReason === \"undefined\" ? reason : returnedReason;\n\t\t\t\t}\n\t\t\t\tcanceled = true;\n\t\t\t\tif(!fulfilled){\n\t\t\t\t\t// Allow canceler to provide its own reason, but fall back to a CancelError\n\t\t\t\t\tif(typeof reason === \"undefined\"){\n\t\t\t\t\t\treason = new CancelError();\n\t\t\t\t\t}\n\t\t\t\t\treject(reason);\n\t\t\t\t\treturn reason;\n\t\t\t\t}else if(fulfilled === REJECTED && result === reason){\n\t\t\t\t\treturn reason;\n\t\t\t\t}\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}\n\t\t};\n\n\t\tfreezeObject(promise);\n\t};\n\n\tDeferred.prototype.toString = function(){\n\t\t// returns: String\n\t\t//\t\tReturns `[object Deferred]`.\n\n\t\treturn \"[object Deferred]\";\n\t};\n\n\tif(instrumentation){\n\t\tinstrumentation(Deferred);\n\t}\n\n\treturn Deferred;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/Deferred.js?");

/***/ }),

/***/ "./node_modules/dojo/Evented.js":
/*!**************************************!*\
  !*** ./node_modules/dojo/Evented.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! ./on */ \"./node_modules/dojo/on.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(aspect, on){\n\t// module:\n\t//\t\tdojo/Evented\n\n \t\"use strict\";\n \tvar after = aspect.after;\n\tfunction Evented(){\n\t\t// summary:\n\t\t//\t\tA class that can be used as a mixin or base class,\n\t\t//\t\tto add on() and emit() methods to a class\n\t\t//\t\tfor listening for events and emitting events:\n\t\t// example:\n\t\t//\t\t|\tdefine([\"dojo/Evented\", \"dojo/_base/declare\", \"dojo/Stateful\"\n\t\t//\t\t|\t], function(Evented, declare, Stateful){\n\t\t//\t\t|\t\tvar EventedStateful = declare([Evented, Stateful], {...});\n\t\t//\t\t|\t\tvar instance = new EventedStateful();\n\t\t//\t\t|\t\tinstance.on(\"open\", function(event){\n\t\t//\t\t|\t\t... do something with event\n\t\t//\t\t|\t });\n\t\t//\t\t|\n\t\t//\t\t|\tinstance.emit(\"open\", {name:\"some event\", ...});\n\t}\n\tEvented.prototype = {\n\t\ton: function(type, listener){\n\t\t\treturn on.parse(this, type, listener, function(target, type){\n\t\t\t\treturn after(target, 'on' + type, listener, true);\n\t\t\t});\n\t\t},\n\t\temit: function(type, event){\n\t\t\tvar args = [this];\n\t\t\targs.push.apply(args, arguments);\n\t\t\treturn on.emit.apply(on, args);\n\t\t}\n\t};\n\treturn Evented;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/Evented.js?");

/***/ }),

/***/ "./node_modules/dojo/aspect.js":
/*!*************************************!*\
  !*** ./node_modules/dojo/aspect.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){\n\n\t// module:\n\t//\t\tdojo/aspect\n\n\t\"use strict\";\n\tvar undefined;\n\tfunction advise(dispatcher, type, advice, receiveArguments){\n\t\tvar previous = dispatcher[type];\n\t\tvar around = type == \"around\";\n\t\tvar signal;\n\t\tif(around){\n\t\t\tvar advised = advice(function(){\n\t\t\t\treturn previous.advice(this, arguments);\n\t\t\t});\n\t\t\tsignal = {\n\t\t\t\tremove: function(){\n\t\t\t\t\tif(advised){\n\t\t\t\t\t\tadvised = dispatcher = advice = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tadvice: function(target, args){\n\t\t\t\t\treturn advised ?\n\t\t\t\t\t\tadvised.apply(target, args) :  // called the advised function\n\t\t\t\t\t\tprevious.advice(target, args); // cancelled, skip to next one\n\t\t\t\t}\n\t\t\t};\n\t\t}else{\n\t\t\t// create the remove handler\n\t\t\tsignal = {\n\t\t\t\tremove: function(){\n\t\t\t\t\tif(signal.advice){\n\t\t\t\t\t\tvar previous = signal.previous;\n\t\t\t\t\t\tvar next = signal.next;\n\t\t\t\t\t\tif(!next && !previous){\n\t\t\t\t\t\t\tdelete dispatcher[type];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(previous){\n\t\t\t\t\t\t\t\tprevious.next = next;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdispatcher[type] = next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(next){\n\t\t\t\t\t\t\t\tnext.previous = previous;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove the advice to signal that this signal has been removed\n\t\t\t\t\t\tdispatcher = advice = signal.advice = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tid: dispatcher.nextId++,\n\t\t\t\tadvice: advice,\n\t\t\t\treceiveArguments: receiveArguments\n\t\t\t};\n\t\t}\n\t\tif(previous && !around){\n\t\t\tif(type == \"after\"){\n\t\t\t\t// add the listener to the end of the list\n\t\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t\t\t\twhile(previous.next && (previous = previous.next)){}\n\t\t\t\tprevious.next = signal;\n\t\t\t\tsignal.previous = previous;\n\t\t\t}else if(type == \"before\"){\n\t\t\t\t// add to beginning\n\t\t\t\tdispatcher[type] = signal;\n\t\t\t\tsignal.next = previous;\n\t\t\t\tprevious.previous = signal;\n\t\t\t}\n\t\t}else{\n\t\t\t// around or first one just replaces\n\t\t\tdispatcher[type] = signal;\n\t\t}\n\t\treturn signal;\n\t}\n\tfunction aspect(type){\n\t\treturn function(target, methodName, advice, receiveArguments){\n\t\t\tvar existing = target[methodName], dispatcher;\n\t\t\tif(!existing || existing.target != target){\n\t\t\t\t// no dispatcher in place\n\t\t\t\ttarget[methodName] = dispatcher = function(){\n\t\t\t\t\tvar executionId = dispatcher.nextId;\n\t\t\t\t\t// before advice\n\t\t\t\t\tvar args = arguments;\n\t\t\t\t\tvar before = dispatcher.before;\n\t\t\t\t\twhile(before){\n\t\t\t\t\t\tif(before.advice){\n\t\t\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbefore = before.next;\n\t\t\t\t\t}\n\t\t\t\t\t// around advice\n\t\t\t\t\tif(dispatcher.around){\n\t\t\t\t\t\tvar results = dispatcher.around.advice(this, args);\n\t\t\t\t\t}\n\t\t\t\t\t// after advice\n\t\t\t\t\tvar after = dispatcher.after;\n\t\t\t\t\twhile(after && after.id < executionId){\n\t\t\t\t\t\tif(after.advice){\n\t\t\t\t\t\t\tif(after.receiveArguments){\n\t\t\t\t\t\t\t\tvar newResults = after.advice.apply(this, args);\n\t\t\t\t\t\t\t\t// change the return value only if a new value was returned\n\t\t\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tresults = after.advice.call(this, results, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tafter = after.next;\n\t\t\t\t\t}\n\t\t\t\t\treturn results;\n\t\t\t\t};\n\t\t\t\tif(existing){\n\t\t\t\t\tdispatcher.around = {advice: function(target, args){\n\t\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tdispatcher.target = target;\n\t\t\t\tdispatcher.nextId = dispatcher.nextId || 0;\n\t\t\t}\n\t\t\tvar results = advise((dispatcher || existing), type, advice, receiveArguments);\n\t\t\tadvice = null;\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// TODOC: after/before/around return object\n\n\tvar after = aspect(\"after\");\n\t/*=====\n\tafter = function(target, methodName, advice, receiveArguments){\n\t\t// summary:\n\t\t//\t\tThe \"after\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"after\" advice to a method. This function will be executed after the original method\n\t\t//\t\tis executed. By default the function will be called with a single argument, the return\n\t\t//\t\tvalue of the original method, or the the return value of the last executed advice (if a previous one exists).\n\t\t//\t\tThe fourth (optional) argument can be set to true to so the function receives the original\n\t\t//\t\targuments (from when the original method was called) rather than the return value.\n\t\t//\t\tIf there are multiple \"after\" advisors, they are executed in the order they were registered.\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called after the original method\n\t\t// receiveArguments: Boolean?\n\t\t//\t\tIf this is set to true, the advice function receives the original arguments (from when the original mehtod\n\t\t//\t\twas called) rather than the return value of the original/previous method.\n\t\t// returns:\n\t\t//\t\tA signal object that can be used to cancel the advice. If remove() is called on this signal object, it will\n\t\t//\t\tstop the advice function from being executed.\n\t};\n\t=====*/\n\n\tvar before = aspect(\"before\");\n\t/*=====\n\tbefore = function(target, methodName, advice){\n\t\t// summary:\n\t\t//\t\tThe \"before\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"before\" advice to a method. This function will be executed before the original method\n\t\t//\t\tis executed. This function will be called with the arguments used to call the method.\n\t\t//\t\tThis function may optionally return an array as the new arguments to use to call\n\t\t//\t\tthe original method (or the previous, next-to-execute before advice, if one exists).\n\t\t//\t\tIf the before method doesn't return anything (returns undefined) the original arguments\n\t\t//\t\twill be preserved.\n\t\t//\t\tIf there are multiple \"before\" advisors, they are executed in the reverse order they were registered.\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called before the original method\n\t};\n\t=====*/\n\n\tvar around = aspect(\"around\");\n\t/*=====\n\t around = function(target, methodName, advice){\n\t\t// summary:\n\t\t//\t\tThe \"around\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"around\" advice to a method. The advisor function is immediately executed when\n\t\t//\t\tthe around() is called, is passed a single argument that is a function that can be\n\t\t//\t\tcalled to continue execution of the original method (or the next around advisor).\n\t\t//\t\tThe advisor function should return a function, and this function will be called whenever\n\t\t//\t\tthe method is called. It will be called with the arguments used to call the method.\n\t\t//\t\tWhatever this function returns will be returned as the result of the method call (unless after advise changes it).\n\t\t// example:\n\t\t//\t\tIf there are multiple \"around\" advisors, the most recent one is executed first,\n\t\t//\t\twhich can then delegate to the next one and so on. For example:\n\t\t//\t\t|\taround(obj, \"foo\", function(originalFoo){\n\t\t//\t\t|\t\treturn function(){\n\t\t//\t\t|\t\t\tvar start = new Date().getTime();\n\t\t//\t\t|\t\t\tvar results = originalFoo.apply(this, arguments); // call the original\n\t\t//\t\t|\t\t\tvar end = new Date().getTime();\n\t\t//\t\t|\t\t\tconsole.log(\"foo execution took \" + (end - start) + \" ms\");\n\t\t//\t\t|\t\t\treturn results;\n\t\t//\t\t|\t\t};\n\t\t//\t\t|\t});\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called around the original method\n\t};\n\t=====*/\n\n\treturn {\n\t\t// summary:\n\t\t//\t\tprovides aspect oriented programming functionality, allowing for\n\t\t//\t\tone to add before, around, or after advice on existing methods.\n\t\t// example:\n\t\t//\t|\tdefine([\"dojo/aspect\"], function(aspect){\n\t\t//\t|\t\tvar signal = aspect.after(targetObject, \"methodName\", function(someArgument){\n\t\t//\t|\t\t\tthis will be called when targetObject.methodName() is called, after the original function is called\n\t\t//\t|\t\t});\n\t\t//\n\t\t// example:\n\t\t//\tThe returned signal object can be used to cancel the advice.\n\t\t//\t|\tsignal.remove(); // this will stop the advice from being executed anymore\n\t\t//\t|\taspect.before(targetObject, \"methodName\", function(someArgument){\n\t\t//\t|\t\t// this will be called when targetObject.methodName() is called, before the original function is called\n\t\t//\t|\t });\n\n\t\tbefore: before,\n\t\taround: around,\n\t\tafter: after\n\t};\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/aspect.js?");

/***/ }),

/***/ "./node_modules/dojo/errors/CancelError.js":
/*!*************************************************!*\
  !*** ./node_modules/dojo/errors/CancelError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./create */ \"./node_modules/dojo/errors/create.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(create){\n\t// module:\n\t//\t\tdojo/errors/CancelError\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tDefault error if a promise is canceled without a reason.\n\t};\n\t=====*/\n\n\treturn create(\"CancelError\", null, null, { dojoType: \"cancel\", log: false });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/errors/CancelError.js?");

/***/ }),

/***/ "./node_modules/dojo/errors/create.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/errors/create.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang){\n\treturn function(name, ctor, base, props){\n\t\tbase = base || Error;\n\n\t\tvar ErrorCtor = function(message){\n\t\t\tif(base === Error){\n\t\t\t\tif(Error.captureStackTrace){\n\t\t\t\t\tError.captureStackTrace(this, ErrorCtor);\n\t\t\t\t}\n\n\t\t\t\t// Error.call() operates on the returned error\n\t\t\t\t// object rather than operating on |this|\n\t\t\t\tvar err = Error.call(this, message),\n\t\t\t\t\tprop;\n\n\t\t\t\t// Copy own properties from err to |this|\n\t\t\t\tfor(prop in err){\n\t\t\t\t\tif(err.hasOwnProperty(prop)){\n\t\t\t\t\t\tthis[prop] = err[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// messsage is non-enumerable in ES5\n\t\t\t\tthis.message = message;\n\t\t\t\t// stack is non-enumerable in at least Firefox\n\t\t\t\tthis.stack = err.stack;\n\t\t\t}else{\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t}\n\t\t\tif(ctor){\n\t\t\t\tctor.apply(this, arguments);\n\t\t\t}\n\t\t};\n\n\t\tErrorCtor.prototype = lang.delegate(base.prototype, props);\n\t\tErrorCtor.prototype.name = name;\n\t\tErrorCtor.prototype.constructor = ErrorCtor;\n\n\t\treturn ErrorCtor;\n\t};\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/errors/create.js?");

/***/ }),

/***/ "./node_modules/dojo/on.js":
/*!*********************************!*\
  !*** ./node_modules/dojo/on.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__.dj.h(\"dom-addeventlistener?:./node_modules/dojo/aspect.js\"), __webpack_require__(/*! ./_base/kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! ./sniff */ \"./node_modules/dojo/sniff.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(aspect, dojo, has){\n\n\t\"use strict\";\n\tif(has(\"dom\")){ // check to make sure we are in a browser, this module should work anywhere\n\t\tvar major = window.ScriptEngineMajorVersion;\n\t\thas.add(\"jscript\", major && (major() + ScriptEngineMinorVersion() / 10));\n\t\thas.add(\"event-orientationchange\", has(\"touch\") && !has(\"android\")); // TODO: how do we detect this?\n\t\thas.add(\"event-stopimmediatepropagation\", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);\n\t\thas.add(\"event-focusin\", function(global, doc, element){\n\t\t\treturn 'onfocusin' in element;\n\t\t});\n\n\t\tif(has(\"touch\")){\n\t\t\thas.add(\"touch-can-modify-event-delegate\", function(){\n\t\t\t\t// This feature test checks whether deleting a property of an event delegate works\n\t\t\t\t// for a touch-enabled device. If it works, event delegation can be used as fallback\n\t\t\t\t// for browsers such as Safari in older iOS where deleting properties of the original\n\t\t\t\t// event does not work.\n\t\t\t\tvar EventDelegate = function(){};\n\t\t\t\tEventDelegate.prototype =\n\t\t\t\t\tdocument.createEvent(\"MouseEvents\"); // original event\n\t\t\t\t// Attempt to modify a property of an event delegate and check if\n\t\t\t\t// it succeeds. Depending on browsers and on whether dojo/on's\n\t\t\t\t// strict mode is stripped in a Dojo build, there are 3 known behaviors:\n\t\t\t\t// it may either succeed, or raise an error, or fail to set the property\n\t\t\t\t// without raising an error.\n\t\t\t\ttry{\n\t\t\t\t\tvar eventDelegate = new EventDelegate;\n\t\t\t\t\teventDelegate.target = null;\n\t\t\t\t\treturn eventDelegate.target === null;\n\t\t\t\t}catch(e){\n\t\t\t\t\treturn false; // cannot use event delegation\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tvar on = function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tA function that provides core event listening functionality. With this function\n\t\t//\t\tyou can provide a target, event type, and listener to be notified of\n\t\t//\t\tfuture matching events that are fired.\n\t\t// target: Element|Object\n\t\t//\t\tThis is the target object or DOM element that to receive events from\n\t\t// type: String|Function\n\t\t//\t\tThis is the name of the event to listen for or an extension event type.\n\t\t// listener: Function\n\t\t//\t\tThis is the function that should be called when the event fires.\n\t\t// returns: Object\n\t\t//\t\tAn object with a remove() method that can be used to stop listening for this\n\t\t//\t\tevent.\n\t\t// description:\n\t\t//\t\tTo listen for \"click\" events on a button node, we can do:\n\t\t//\t\t|\tdefine([\"dojo/on\"], function(on){\n\t\t//\t\t|\t\ton(button, \"click\", clickHandler);\n\t\t//\t\t|\t\t...\n\t\t//\t\tEvented JavaScript objects can also have their own events.\n\t\t//\t\t|\tvar obj = new Evented;\n\t\t//\t\t|\ton(obj, \"foo\", fooHandler);\n\t\t//\t\tAnd then we could publish a \"foo\" event:\n\t\t//\t\t|\ton.emit(obj, \"foo\", {key: \"value\"});\n\t\t//\t\tWe can use extension events as well. For example, you could listen for a tap gesture:\n\t\t//\t\t|\tdefine([\"dojo/on\", \"dojo/gesture/tap\", function(on, tap){\n\t\t//\t\t|\t\ton(button, tap, tapHandler);\n\t\t//\t\t|\t\t...\n\t\t//\t\twhich would trigger fooHandler. Note that for a simple object this is equivalent to calling:\n\t\t//\t\t|\tobj.onfoo({key:\"value\"});\n\t\t//\t\tIf you use on.emit on a DOM node, it will use native event dispatching when possible.\n\n\t\tif(typeof target.on == \"function\" && typeof type != \"function\" && !target.nodeType){\n\t\t\t// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it\n\t\t\t// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the\n\t\t\t// Element prototype\n\t\t\treturn target.on(type, listener);\n\t\t}\n\t\t// delegate to main listener code\n\t\treturn on.parse(target, type, listener, addListener, dontFix, this);\n\t};\n\ton.pausable =  function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tThis function acts the same as on(), but with pausable functionality. The\n\t\t//\t\treturned signal object has pause() and resume() functions. Calling the\n\t\t//\t\tpause() method will cause the listener to not be called for future events. Calling the\n\t\t//\t\tresume() method will cause the listener to again be called for future events.\n\t\tvar paused;\n\t\tvar signal = on(target, type, function(){\n\t\t\tif(!paused){\n\t\t\t\treturn listener.apply(this, arguments);\n\t\t\t}\n\t\t}, dontFix);\n\t\tsignal.pause = function(){\n\t\t\tpaused = true;\n\t\t};\n\t\tsignal.resume = function(){\n\t\t\tpaused = false;\n\t\t};\n\t\treturn signal;\n\t};\n\ton.once = function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tThis function acts the same as on(), but will only call the listener once. The\n\t\t//\t\tlistener will be called for the first\n\t\t//\t\tevent that takes place and then listener will automatically be removed.\n\t\tvar signal = on(target, type, function(){\n\t\t\t// remove this listener\n\t\t\tsignal.remove();\n\t\t\t// proceed to call the listener\n\t\t\treturn listener.apply(this, arguments);\n\t\t});\n\t\treturn signal;\n\t};\n\ton.parse = function(target, type, listener, addListener, dontFix, matchesTarget){\n\t\tvar events;\n\t\tif(type.call){\n\t\t\t// event handler function\n\t\t\t// on(node, touch.press, touchListener);\n\t\t\treturn type.call(matchesTarget, target, listener);\n\t\t}\n\n\t\tif(type instanceof Array){\n\t\t\t// allow an array of event names (or event handler functions)\n\t\t\tevents = type;\n\t\t}else if(type.indexOf(\",\") > -1){\n\t\t\t// we allow comma delimited event names, so you can register for multiple events at once\n\t\t\tevents = type.split(/\\s*,\\s*/);\n\t\t}\n\t\tif(events){\n\t\t\tvar handles = [];\n\t\t\tvar i = 0;\n\t\t\tvar eventName;\n\t\t\twhile(eventName = events[i++]){ // intentional assignment\n\t\t\t\thandles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));\n\t\t\t}\n\t\t\thandles.remove = function(){\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\n\t\t\t\t\thandles[i].remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handles;\n\t\t}\n\t\treturn addListener(target, type, listener, dontFix, matchesTarget);\n\t};\n\tvar touchEvents = /^touch/;\n\tfunction addListener(target, type, listener, dontFix, matchesTarget){\n\t\t// event delegation:\n\t\tvar selector = type.match(/(.*):(.*)/);\n\t\t// if we have a selector:event, the last one is interpreted as an event, and we use event delegation\n\t\tif(selector){\n\t\t\ttype = selector[2];\n\t\t\tselector = selector[1];\n\t\t\t// create the extension event for selectors and directly call it\n\t\t\treturn on.selector(selector, type).call(matchesTarget, target, listener);\n\t\t}\n\t\t// test to see if it a touch event right now, so we don't have to do it every time it fires\n\t\tif(has(\"touch\")){\n\t\t\tif(touchEvents.test(type)){\n\t\t\t\t// touch event, fix it\n\t\t\t\tlistener = fixTouchListener(listener);\n\t\t\t}\n\t\t\tif(!has(\"event-orientationchange\") && (type == \"orientationchange\")){\n\t\t\t\t//\"orientationchange\" not supported <= Android 2.1,\n\t\t\t\t//but works through \"resize\" on window\n\t\t\t\ttype = \"resize\";\n\t\t\t\ttarget = window;\n\t\t\t\tlistener = fixTouchListener(listener);\n\t\t\t}\n\t\t}\n\t\tif(addStopImmediate){\n\t\t\t// add stopImmediatePropagation if it doesn't exist\n\t\t\tlistener = addStopImmediate(listener);\n\t\t}\n\t\t// normal path, the target is |this|\n\t\tif(target.addEventListener){\n\t\t\t// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)\n\t\t\t// check for capture conversions\n\t\t\tvar capture = type in captures,\n\t\t\t\tadjustedType = capture ? captures[type] : type;\n\t\t\ttarget.addEventListener(adjustedType, listener, capture);\n\t\t\t// create and return the signal\n\t\t\treturn {\n\t\t\t\tremove: function(){\n\t\t\t\t\ttarget.removeEventListener(adjustedType, listener, capture);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\ttype = \"on\" + type;\n\t\tif(fixAttach && target.attachEvent){\n\t\t\treturn fixAttach(target, type, listener);\n\t\t}\n\t\tthrow new Error(\"Target must be an event emitter\");\n\t}\n\ton.matches = function(node, selector, context, children, matchesTarget) {\n\t\t// summary:\n\t\t//\t\tCheck if a node match the current selector within the constraint of a context\n\t\t// node: DOMNode\n\t\t//\t\tThe node that originate the event\n\t\t// selector: String\n\t\t//\t\tThe selector to check against\n\t\t// context: DOMNode\n\t\t//\t\tThe context to search in.\n\t\t// children: Boolean\n\t\t//\t\tIndicates if children elements of the selector should be allowed. This defaults to\n\t\t//\t\ttrue\n\t\t// matchesTarget: Object|dojo/query?\n\t\t//\t\tAn object with a property \"matches\" as a function. Default is dojo/query.\n\t\t//\t\tMatching DOMNodes will be done against this function\n\t\t//\t\tThe function must return a Boolean.\n\t\t//\t\tIt will have 3 arguments: \"node\", \"selector\" and \"context\"\n\t\t//\t\tTrue is expected if \"node\" is matching the current \"selector\" in the passed \"context\"\n\t\t// returns: DOMNode?\n\t\t//\t\tThe matching node, if any. Else you get false\n\n\t\t// see if we have a valid matchesTarget or default to dojo/query\n\t\tmatchesTarget = matchesTarget && (typeof matchesTarget.matches == \"function\") ? matchesTarget : dojo.query;\n\t\tchildren = children !== false;\n\t\t// there is a selector, so make sure it matches\n\t\tif(node.nodeType != 1){\n\t\t\t// text node will fail in native match selector\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\twhile(!matchesTarget.matches(node, selector, context)){\n\t\t\tif(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t};\n\ton.selector = function(selector, eventType, children){\n\t\t// summary:\n\t\t//\t\tCreates a new extension event with event delegation. This is based on\n\t\t//\t\tthe provided event type (can be extension event) that\n\t\t//\t\tonly calls the listener when the CSS selector matches the target of the event.\n\t\t//\n\t\t//\t\tThe application must require() an appropriate level of dojo/query to handle the selector.\n\t\t// selector:\n\t\t//\t\tThe CSS selector to use for filter events and determine the |this| of the event listener.\n\t\t// eventType:\n\t\t//\t\tThe event to listen for\n\t\t// children:\n\t\t//\t\tIndicates if children elements of the selector should be allowed. This defaults to\n\t\t//\t\ttrue\n\t\t// example:\n\t\t// |\trequire([\"dojo/on\", \"dojo/mouse\", \"dojo/query!css2\"], function(on, mouse){\n\t\t// |\t\ton(node, on.selector(\".my-class\", mouse.enter), handlerForMyHover);\n\t\treturn function(target, listener){\n\t\t\t// if the selector is function, use it to select the node, otherwise use the matches method\n\t\t\tvar matchesTarget = typeof selector == \"function\" ? {matches: selector} : this,\n\t\t\t\tbubble = eventType.bubble;\n\t\t\tfunction select(eventTarget){\n\t\t\t\treturn on.matches(eventTarget, selector, target, children, matchesTarget);\n\t\t\t}\n\t\t\tif(bubble){\n\t\t\t\t// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself\n\t\t\t\treturn on(target, bubble(select), listener);\n\t\t\t}\n\t\t\t// standard event delegation\n\t\t\treturn on(target, eventType, function(event){\n\t\t\t\t// call select to see if we match\n\t\t\t\tvar eventTarget = select(event.target);\n\t\t\t\t// if it matches we call the listener\n\t\t\t\tif (eventTarget) {\n\t\t\t\t\t// We save the matching target into the event, so it can be accessed even when hitching (see #18355)\n\t\t\t\t\tevent.selectorTarget = eventTarget;\n\t\t\t\t\treturn listener.call(eventTarget, event);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n\n\tfunction syntheticPreventDefault(){\n\t\tthis.cancelable = false;\n\t\tthis.defaultPrevented = true;\n\t}\n\tfunction syntheticStopPropagation(){\n\t\tthis.bubbles = false;\n\t}\n\tvar slice = [].slice,\n\t\tsyntheticDispatch = on.emit = function(target, type, event){\n\t\t// summary:\n\t\t//\t\tFires an event on the target object.\n\t\t// target:\n\t\t//\t\tThe target object to fire the event on. This can be a DOM element or a plain\n\t\t//\t\tJS object. If the target is a DOM element, native event emitting mechanisms\n\t\t//\t\tare used when possible.\n\t\t// type:\n\t\t//\t\tThe event type name. You can emulate standard native events like \"click\" and\n\t\t//\t\t\"mouseover\" or create custom events like \"open\" or \"finish\".\n\t\t// event:\n\t\t//\t\tAn object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent\n\t\t//\t\tfor some of the properties. These properties are copied to the event object.\n\t\t//\t\tOf particular importance are the cancelable and bubbles properties. The\n\t\t//\t\tcancelable property indicates whether or not the event has a default action\n\t\t//\t\tthat can be cancelled. The event is cancelled by calling preventDefault() on\n\t\t//\t\tthe event object. The bubbles property indicates whether or not the\n\t\t//\t\tevent will bubble up the DOM tree. If bubbles is true, the event will be called\n\t\t//\t\ton the target and then each parent successively until the top of the tree\n\t\t//\t\tis reached or stopPropagation() is called. Both bubbles and cancelable\n\t\t//\t\tdefault to false.\n\t\t// returns:\n\t\t//\t\tIf the event is cancelable and the event is not cancelled,\n\t\t//\t\temit will return true. If the event is cancelable and the event is cancelled,\n\t\t//\t\temit will return false.\n\t\t// details:\n\t\t//\t\tNote that this is designed to emit events for listeners registered through\n\t\t//\t\tdojo/on. It should actually work with any event listener except those\n\t\t//\t\tadded through IE's attachEvent (IE8 and below's non-W3C event emitting\n\t\t//\t\tdoesn't support custom event types). It should work with all events registered\n\t\t//\t\tthrough dojo/on. Also note that the emit method does do any default\n\t\t//\t\taction, it only returns a value to indicate if the default action should take\n\t\t//\t\tplace. For example, emitting a keypress event would not cause a character\n\t\t//\t\tto appear in a textbox.\n\t\t// example:\n\t\t//\t\tTo fire our own click event\n\t\t//\t|\trequire([\"dojo/on\", \"dojo/dom\"\n\t\t//\t|\t], function(on, dom){\n\t\t//\t|\t\ton.emit(dom.byId(\"button\"), \"click\", {\n\t\t//\t|\t\t\tcancelable: true,\n\t\t//\t|\t\t\tbubbles: true,\n\t\t//\t|\t\t\tscreenX: 33,\n\t\t//\t|\t\t\tscreenY: 44\n\t\t//\t|\t\t});\n\t\t//\t\tWe can also fire our own custom events:\n\t\t//\t|\t\ton.emit(dom.byId(\"slider\"), \"slide\", {\n\t\t//\t|\t\t\tcancelable: true,\n\t\t//\t|\t\t\tbubbles: true,\n\t\t//\t|\t\t\tdirection: \"left-to-right\"\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\tvar args = slice.call(arguments, 2);\n\t\tvar method = \"on\" + type;\n\t\tif(\"parentNode\" in target){\n\t\t\t// node (or node-like), create event controller methods\n\t\t\tvar newEvent = args[0] = {};\n\t\t\tfor(var i in event){\n\t\t\t\tnewEvent[i] = event[i];\n\t\t\t}\n\t\t\tnewEvent.preventDefault = syntheticPreventDefault;\n\t\t\tnewEvent.stopPropagation = syntheticStopPropagation;\n\t\t\tnewEvent.target = target;\n\t\t\tnewEvent.type = type;\n\t\t\tevent = newEvent;\n\t\t}\n\t\tdo{\n\t\t\t// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)\n\t\t\ttarget[method] && target[method].apply(target, args);\n\t\t\t// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)\n\t\t}while(event && event.bubbles && (target = target.parentNode));\n\t\treturn event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen\n\t};\n\tvar captures = has(\"event-focusin\") ? {} : {focusin: \"focus\", focusout: \"blur\"};\n\tif(!has(\"event-stopimmediatepropagation\")){\n\t\tvar stopImmediatePropagation =function(){\n\t\t\tthis.immediatelyStopped = true;\n\t\t\tthis.modified = true; // mark it as modified so the event will be cached in IE\n\t\t};\n\t\tvar addStopImmediate = function(listener){\n\t\t\treturn function(event){\n\t\t\t\tif(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately\n\t\t\t\t\tevent.stopImmediatePropagation = stopImmediatePropagation;\n\t\t\t\t\treturn listener.apply(this, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\tif(has(\"dom-addeventlistener\")){\n\t\t// emitter that works with native event handling\n\t\ton.emit = function(target, type, event){\n\t\t\tif(target.dispatchEvent && document.createEvent){\n\t\t\t\t// use the native event emitting mechanism if it is available on the target object\n\t\t\t\t// create a generic event\n\t\t\t\t// we could create branch into the different types of event constructors, but\n\t\t\t\t// that would be a lot of extra code, with little benefit that I can see, seems\n\t\t\t\t// best to use the generic constructor and copy properties over, making it\n\t\t\t\t// easy to have events look like the ones created with specific initializers\n\t\t\t\tvar ownerDocument = target.ownerDocument || document;\n\t\t\t\tvar nativeEvent = ownerDocument.createEvent(\"HTMLEvents\");\n\t\t\t\tnativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);\n\t\t\t\t// and copy all our properties over\n\t\t\t\tfor(var i in event){\n\t\t\t\t\tif(!(i in nativeEvent)){\n\t\t\t\t\t\tnativeEvent[i] = event[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target.dispatchEvent(nativeEvent) && nativeEvent;\n\t\t\t}\n\t\t\treturn syntheticDispatch.apply(on, arguments); // emit for a non-node\n\t\t};\n\t}else{\n\t\t// no addEventListener, basically old IE event normalization\n\t\ton._fixEvent = function(evt, sender){\n\t\t\t// summary:\n\t\t\t//\t\tnormalizes properties on the event object including event\n\t\t\t//\t\tbubbling methods, keystroke normalization, and x/y positions\n\t\t\t// evt:\n\t\t\t//\t\tnative event object\n\t\t\t// sender:\n\t\t\t//\t\tnode to treat as \"currentTarget\"\n\t\t\tif(!evt){\n\t\t\t\tvar w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;\n\t\t\t\tevt = w.event;\n\t\t\t}\n\t\t\tif(!evt){return evt;}\n\t\t\ttry{\n\t\t\t\tif(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){\n\t\t\t\t\t// should be same event, reuse event object (so it can be augmented);\n\t\t\t\t\t// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below\n\t\t\t\t\tevt = lastEvent;\n\t\t\t\t}\n\t\t\t}catch(e){\n\t\t\t\t// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already\n\t\t\t\t// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet\n\t\t\t}\n\t\t\tif(!evt.target){ // check to see if it has been fixed yet\n\t\t\t\tevt.target = evt.srcElement;\n\t\t\t\tevt.currentTarget = (sender || evt.srcElement);\n\t\t\t\tif(evt.type == \"mouseover\"){\n\t\t\t\t\tevt.relatedTarget = evt.fromElement;\n\t\t\t\t}\n\t\t\t\tif(evt.type == \"mouseout\"){\n\t\t\t\t\tevt.relatedTarget = evt.toElement;\n\t\t\t\t}\n\t\t\t\tif(!evt.stopPropagation){\n\t\t\t\t\tevt.stopPropagation = stopPropagation;\n\t\t\t\t\tevt.preventDefault = preventDefault;\n\t\t\t\t}\n\t\t\t\tswitch(evt.type){\n\t\t\t\t\tcase \"keypress\":\n\t\t\t\t\t\tvar c = (\"charCode\" in evt ? evt.charCode : evt.keyCode);\n\t\t\t\t\t\tif (c==10){\n\t\t\t\t\t\t\t// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla\n\t\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\tevt.keyCode = 13;\n\t\t\t\t\t\t}else if(c==13||c==27){\n\t\t\t\t\t\t\tc=0; // Mozilla considers ENTER and ESC non-printable\n\t\t\t\t\t\t}else if(c==3){\n\t\t\t\t\t\t\tc=99; // Mozilla maps CTRL-BREAK to CTRL-c\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Mozilla sets keyCode to 0 when there is a charCode\n\t\t\t\t\t\t// but that stops the event on IE.\n\t\t\t\t\t\tevt.charCode = c;\n\t\t\t\t\t\t_setKeyChar(evt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn evt;\n\t\t};\n\t\tvar lastEvent, IESignal = function(handle){\n\t\t\tthis.handle = handle;\n\t\t};\n\t\tIESignal.prototype.remove = function(){\n\t\t\tdelete _dojoIEListeners_[this.handle];\n\t\t};\n\t\tvar fixListener = function(listener){\n\t\t\t// this is a minimal function for closing on the previous listener with as few as variables as possible\n\t\t\treturn function(evt){\n\t\t\t\tevt = on._fixEvent(evt, this);\n\t\t\t\tvar result = listener.call(this, evt);\n\t\t\t\tif(evt.modified){\n\t\t\t\t\t// cache the last event and reuse it if we can\n\t\t\t\t\tif(!lastEvent){\n\t\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\tlastEvent = null;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tlastEvent = evt;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t};\n\t\tvar fixAttach = function(target, type, listener){\n\t\t\tlistener = fixListener(listener);\n\t\t\tif(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top ||\n\t\t\t\t\t\thas(\"jscript\") < 5.8) &&\n\t\t\t\t\t!has(\"config-_allow_leaks\")){\n\t\t\t\t// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.\n\t\t\t\t// Here we use global redirection to solve the memory leaks\n\t\t\t\tif(typeof _dojoIEListeners_ == \"undefined\"){\n\t\t\t\t\t_dojoIEListeners_ = [];\n\t\t\t\t}\n\t\t\t\tvar emitter = target[type];\n\t\t\t\tif(!emitter || !emitter.listeners){\n\t\t\t\t\tvar oldListener = emitter;\n\t\t\t\t\temitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');\n\t\t\t\t\temitter.listeners = [];\n\t\t\t\t\ttarget[type] = emitter;\n\t\t\t\t\temitter.global = this;\n\t\t\t\t\tif(oldListener){\n\t\t\t\t\t\temitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar handle;\n\t\t\t\temitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));\n\t\t\t\treturn new IESignal(handle);\n\t\t\t}\n\t\t\treturn aspect.after(target, type, listener, true);\n\t\t};\n\n\t\tvar _setKeyChar = function(evt){\n\t\t\tevt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';\n\t\t\tevt.charOrCode = evt.keyChar || evt.keyCode;\t// TODO: remove for 2.0\n\t\t};\n\t\t// Called in Event scope\n\t\tvar stopPropagation = function(){\n\t\t\tthis.cancelBubble = true;\n\t\t};\n\t\tvar preventDefault = on._preventDefault = function(){\n\t\t\t// Setting keyCode to 0 is the only way to prevent certain keypresses (namely\n\t\t\t// ctrl-combinations that correspond to menu accelerator keys).\n\t\t\t// Otoh, it prevents upstream listeners from getting this information\n\t\t\t// Try to split the difference here by clobbering keyCode only for ctrl\n\t\t\t// combinations. If you still need to access the key upstream, bubbledKeyCode is\n\t\t\t// provided as a workaround.\n\t\t\tthis.bubbledKeyCode = this.keyCode;\n\t\t\tif(this.ctrlKey){\n\t\t\t\ttry{\n\t\t\t\t\t// squelch errors when keyCode is read-only\n\t\t\t\t\t// (e.g. if keyCode is ctrl or shift)\n\t\t\t\t\tthis.keyCode = 0;\n\t\t\t\t}catch(e){\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.defaultPrevented = true;\n\t\t\tthis.returnValue = false;\n\t\t\tthis.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE\n\t\t};\n\t}\n\tif(has(\"touch\")){\n\t\tvar EventDelegate = function(){};\n\t\tvar windowOrientation = window.orientation;\n\t\tvar fixTouchListener = function(listener){\n\t\t\treturn function(originalEvent){\n\t\t\t\t//Event normalization(for ontouchxxx and resize):\n\t\t\t\t//1.incorrect e.pageX|pageY in iOS\n\t\t\t\t//2.there are no \"e.rotation\", \"e.scale\" and \"onorientationchange\" in Android\n\t\t\t\t//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY\n\n\t\t\t\t// see if it has already been corrected\n\t\t\t\tvar event = originalEvent.corrected;\n\t\t\t\tif(!event){\n\t\t\t\t\tvar type = originalEvent.type;\n\t\t\t\t\ttry{\n\t\t\t\t\t\tdelete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable\n\t\t\t\t\t}catch(e){}\n\t\t\t\t\tif(originalEvent.type){\n\t\t\t\t\t\t// Deleting the property of the original event did not work (this is the case of\n\t\t\t\t\t\t// browsers such as older Safari iOS), hence fallback:\n\t\t\t\t\t\tif(has(\"touch-can-modify-event-delegate\")){\n\t\t\t\t\t\t\t// If deleting properties of delegated event works, use event delegation:\n\t\t\t\t\t\t\tEventDelegate.prototype = originalEvent;\n\t\t\t\t\t\t\tevent = new EventDelegate;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// Otherwise last fallback: other browsers, such as mobile Firefox, do not like\n\t\t\t\t\t\t\t// delegated properties, so we have to copy\n\t\t\t\t\t\t\tevent = {};\n\t\t\t\t\t\t\tfor(var name in originalEvent){\n\t\t\t\t\t\t\t\tevent[name] = originalEvent[name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// have to delegate methods to make them work\n\t\t\t\t\t\tevent.preventDefault = function(){\n\t\t\t\t\t\t\toriginalEvent.preventDefault();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tevent.stopPropagation = function(){\n\t\t\t\t\t\t\toriginalEvent.stopPropagation();\n\t\t\t\t\t\t};\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// deletion worked, use property as is\n\t\t\t\t\t\tevent = originalEvent;\n\t\t\t\t\t\tevent.type = type;\n\t\t\t\t\t}\n\t\t\t\t\toriginalEvent.corrected = event;\n\t\t\t\t\tif(type == 'resize'){\n\t\t\t\t\t\tif(windowOrientation == window.orientation){\n\t\t\t\t\t\t\treturn null;//double tap causes an unexpected 'resize' in Android\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindowOrientation = window.orientation;\n\t\t\t\t\t\tevent.type = \"orientationchange\";\n\t\t\t\t\t\treturn listener.call(this, event);\n\t\t\t\t\t}\n\t\t\t\t\t// We use the original event and augment, rather than doing an expensive mixin operation\n\t\t\t\t\tif(!(\"rotation\" in event)){ // test to see if it has rotation\n\t\t\t\t\t\tevent.rotation = 0;\n\t\t\t\t\t\tevent.scale = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (window.TouchEvent && originalEvent instanceof TouchEvent) {\n\t\t\t\t\t\t// use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target\n\t\t\t\t\t\tvar firstChangeTouch = event.changedTouches[0];\n\t\t\t\t\t\tfor(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here\n\t\t\t\t\t\t\tdelete event[i]; // delete it first to make it mutable\n\t\t\t\t\t\t\tevent[i] = firstChangeTouch[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn listener.call(this, event);\n\t\t\t};\n\t\t};\n\t}\n\treturn on;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/on.js?");

/***/ }),

/***/ "./node_modules/dojo/promise/Promise.js":
/*!**********************************************!*\
  !*** ./node_modules/dojo/promise/Promise.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang){\n\t\"use strict\";\n\n\t// module:\n\t//\t\tdojo/promise/Promise\n\n\tfunction throwAbstract(){\n\t\tthrow new TypeError(\"abstract\");\n\t}\n\n\treturn lang.extend(function Promise(){\n\t\t// summary:\n\t\t//\t\tThe public interface to a deferred.\n\t\t// description:\n\t\t//\t\tThe public interface to a deferred. All promises in Dojo are\n\t\t//\t\tinstances of this class.\n\t}, {\n\t\tthen: function(callback, errback, progback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd new callbacks to the promise.\n\t\t\t// description:\n\t\t\t//\t\tAdd new callbacks to the deferred. Callbacks can be added\n\t\t\t//\t\tbefore or after the deferred is fulfilled.\n\t\t\t// callback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is resolved.\n\t\t\t//\t\tReceives the resolution value.\n\t\t\t// errback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is rejected.\n\t\t\t//\t\tReceives the rejection error.\n\t\t\t// progback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise emits a progress\n\t\t\t//\t\tupdate. Receives the progress update.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the callback(s).\n\t\t\t//\t\tThis can be used for chaining many asynchronous operations.\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tcancel: function(reason, strict){\n\t\t\t// summary:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t// description:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t//\t\tThe deferred's (optional) canceler is invoked and the\n\t\t\t//\t\tdeferred will be left in a rejected state. Can affect other\n\t\t\t//\t\tpromises that originate with the same deferred.\n\t\t\t// reason: any\n\t\t\t//\t\tA message that may be sent to the deferred's canceler,\n\t\t\t//\t\texplaining why it's being canceled.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be canceled.\n\t\t\t// returns: any\n\t\t\t//\t\tReturns the rejection reason if the deferred was canceled\n\t\t\t//\t\tnormally.\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tisResolved: function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the promise has been resolved.\n\t\t\t// returns: Boolean\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tisRejected: function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the promise has been rejected.\n\t\t\t// returns: Boolean\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tisFulfilled: function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the promise has been resolved or rejected.\n\t\t\t// returns: Boolean\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tisCanceled: function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the promise has been canceled.\n\t\t\t// returns: Boolean\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\t\"finally\": function(callback) {\n\t\t\t// summary:\n\t\t\t//\t\tAdd a callback to the promise that will fire whether it\n\t\t\t//\t\tresolves or rejects.\n\t\t\t// description:\n\t\t\t//\t\tConforms to ES2018's `Promise.prototype.finally`.\n\t\t\t//\t\tAdd a callback to the promise that will fire whether it\n\t\t\t//\t\tresolves or rejects. No value is passed to the callback.\n\t\t\t//\t\tReturns a promise that reflects the state of the original promise,\n\t\t\t//\t\twith two exceptions:\n\t\t\t//\t\t- If the callback return a promise, the outer promise will wait\n\t\t\t//\t\tuntil the returned promise is resolved, then it will resolve\n\t\t\t//\t\twith the original value.\n\t\t\t//\t\t- If the callback throws an exception or returns a promise that\n\t\t\t//\t\tis rejected (or rejects later), the outer promise will reject\n\t\t\t//\t\twith the inner promise's rejection reason.\n\t\t\t// callback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is resolved\n\t\t\t//\t\tor rejected. Doesn't receive any value.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise that reflects the state of the original promise,\n\t\t\t//\t\twith two small exceptions (see description).\n\t\t\t//\n\n\t\t\treturn this.then(function (value){\n\t\t\t\tvar valueOrPromise = callback();\n\t\t\t\tif (valueOrPromise && typeof valueOrPromise.then === \"function\"){\n\t\t\t\t\treturn valueOrPromise.then(function (){\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}, function(reason) {\n\t\t\t\tvar valueOrPromise = callback();\n\t\t\t\tif (valueOrPromise && typeof valueOrPromise.then === \"function\"){\n\t\t\t\t\treturn valueOrPromise.then(function (){\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthrow reason;\n\t\t\t});\n\t\t},\n\n\t\talways: function(callbackOrErrback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a callback to be invoked when the promise is resolved\n\t\t\t//\t\tor rejected.\n\t\t\t// callbackOrErrback: Function?\n\t\t\t//\t\tA function that is used both as a callback and errback.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the callback/errback.\n\n\t\t\treturn this.then(callbackOrErrback, callbackOrErrback);\n\t\t},\n\n\t\t\"catch\": function(errback){\n\t\t    // summary:\n\t\t    //\t\tAdd new errbacks to the promise. Follows ECMA specification naming.\n\t\t    // errback: Function?\n\t\t    //\t\tCallback to be invoked when the promise is rejected.\n\t\t    // returns: dojo/promise/Promise\n\t\t    //\t\tReturns a new promise for the result of the errback.\n\n\t\t    return this.then(null, errback);\n\t\t},\n\n\t\totherwise: function(errback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd new errbacks to the promise.\n\t\t\t// errback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is rejected.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the errback.\n\n\t\t\treturn this.then(null, errback);\n\t\t},\n\n\t\ttrace: function(){\n\t\t\treturn this;\n\t\t},\n\n\t\ttraceRejected: function(){\n\t\t\treturn this;\n\t\t},\n\n\t\ttoString: function(){\n\t\t\t// returns: string\n\t\t\t//\t\tReturns `[object Promise]`.\n\n\t\t\treturn \"[object Promise]\";\n\t\t}\n\t});\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/promise/Promise.js?");

/***/ }),

/***/ "./node_modules/dojo/promise/instrumentation.js":
/*!******************************************************!*\
  !*** ./node_modules/dojo/promise/instrumentation.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t__webpack_require__(/*! ./tracer */ \"./node_modules/dojo/promise/tracer.js\"),\n\t__webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"),\n\t__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\"),\n\t__webpack_require__(/*! ../_base/array */ \"./node_modules/dojo/_base/array.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(tracer, has, lang, arrayUtil){\n\thas.add(\"config-useDeferredInstrumentation\", \"report-unhandled-rejections\");\n\n\tfunction logError(error, rejection, deferred){\n\t\tif(error && error.log === false){\n\t\t\treturn;\n\t\t}\n\t\tvar stack = \"\";\n\t\tif(error && error.stack){\n\t\t\tstack += error.stack;\n\t\t}\n\t\tif(rejection && rejection.stack){\n\t\t\tstack += \"\\n    ----------------------------------------\\n    rejected\" + rejection.stack.split(\"\\n\").slice(1).join(\"\\n\").replace(/^\\s+/, \" \");\n\t\t}\n\t\tif(deferred && deferred.stack){\n\t\t\tstack += \"\\n    ----------------------------------------\\n\" + deferred.stack;\n\t\t}\n\t\tconsole.error(error, stack);\n\t}\n\n\tfunction reportRejections(error, handled, rejection, deferred){\n\t\tif(!handled){\n\t\t\tlogError(error, rejection, deferred);\n\t\t}\n\t}\n\n\tvar errors = [];\n\tvar activeTimeout = false;\n\tvar unhandledWait = 1000;\n\tfunction trackUnhandledRejections(error, handled, rejection, deferred){\n\t\t// try to find the existing tracking object\n\t\tif(!arrayUtil.some(errors, function(obj){\n\t\t\tif(obj.error === error){\n\t\t\t\t// found the tracking object for this error\n\t\t\t\tif(handled){\n\t\t\t\t\t// if handled, update the state\n\t\t\t\t\tobj.handled = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t})){\n\t\t\t// no tracking object has been setup, create one\n\t\t\terrors.push({\n\t\t\t\terror: error,\n\t\t\t\trejection: rejection,\n\t\t\t\thandled: handled,\n\t\t\t\tdeferred: deferred,\n\t\t\t\ttimestamp: new Date().getTime()\n\t\t\t});\n\t\t}\n\n\t\tif(!activeTimeout){\n\t\t\tactiveTimeout = setTimeout(logRejected, unhandledWait);\n\t\t}\n\t}\n\n\tfunction logRejected(){\n\t\tvar now = new Date().getTime();\n\t\tvar reportBefore = now - unhandledWait;\n\t\terrors = arrayUtil.filter(errors, function(obj){\n\t\t\t// only report the error if we have waited long enough and\n\t\t\t// it hasn't been handled\n\t\t\tif(obj.timestamp < reportBefore){\n\t\t\t\tif(!obj.handled){\n\t\t\t\t\tlogError(obj.error, obj.rejection, obj.deferred);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\tif(errors.length){\n\t\t\tactiveTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);\n\t\t}else{\n\t\t\tactiveTimeout = false;\n\t\t}\n\t}\n\n\treturn function(Deferred){\n\t\t// summary:\n\t\t//\t\tInitialize instrumentation for the Deferred class.\n\t\t// description:\n\t\t//\t\tInitialize instrumentation for the Deferred class.\n\t\t//\t\tDone automatically by `dojo/Deferred` if the\n\t\t//\t\t`deferredInstrumentation` and `useDeferredInstrumentation`\n\t\t//\t\tconfig options are set.\n\t\t//\n\t\t//\t\tSets up `dojo/promise/tracer` to log to the console.\n\t\t//\n\t\t//\t\tSets up instrumentation of rejected deferreds so unhandled\n\t\t//\t\terrors are logged to the console.\n\n\t\tvar usage = has(\"config-useDeferredInstrumentation\");\n\t\tif(usage){\n\t\t\ttracer.on(\"resolved\", lang.hitch(console, \"log\", \"resolved\"));\n\t\t\ttracer.on(\"rejected\", lang.hitch(console, \"log\", \"rejected\"));\n\t\t\ttracer.on(\"progress\", lang.hitch(console, \"log\", \"progress\"));\n\n\t\t\tvar args = [];\n\t\t\tif(typeof usage === \"string\"){\n\t\t\t\targs = usage.split(\",\");\n\t\t\t\tusage = args.shift();\n\t\t\t}\n\t\t\tif(usage === \"report-rejections\"){\n\t\t\t\tDeferred.instrumentRejected = reportRejections;\n\t\t\t}else if(usage === \"report-unhandled-rejections\" || usage === true || usage === 1){\n\t\t\t\tDeferred.instrumentRejected = trackUnhandledRejections;\n\t\t\t\tunhandledWait = parseInt(args[0], 10) || unhandledWait;\n\t\t\t}else{\n\t\t\t\tthrow new Error(\"Unsupported instrumentation usage <\" + usage + \">\");\n\t\t\t}\n\t\t}\n\t};\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/promise/instrumentation.js?");

/***/ }),

/***/ "./node_modules/dojo/promise/tracer.js":
/*!*********************************************!*\
  !*** ./node_modules/dojo/promise/tracer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\"),\n\t__webpack_require__(/*! ./Promise */ \"./node_modules/dojo/promise/Promise.js\"),\n\t__webpack_require__(/*! ../Evented */ \"./node_modules/dojo/Evented.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, Promise, Evented){\n\t\"use strict\";\n\n\t// module:\n\t//\t\tdojo/promise/tracer\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tTrace promise fulfillment.\n\t\t// description:\n\t\t//\t\tTrace promise fulfillment. Calling `.trace()` or `.traceError()` on a\n\t\t//\t\tpromise enables tracing. Will emit `resolved`, `rejected` or `progress`\n\t\t//\t\tevents.\n\n\t\ton: function(type, listener){\n\t\t\t// summary:\n\t\t\t//\t\tSubscribe to traces.\n\t\t\t// description:\n\t\t\t//\t\tSee `dojo/Evented#on()`.\n\t\t\t// type: String\n\t\t\t//\t\t`resolved`, `rejected`, or `progress`\n\t\t\t// listener: Function\n\t\t\t//\t\tThe listener is passed the traced value and any arguments\n\t\t\t//\t\tthat were used with the `.trace()` call.\n\t\t}\n\t};\n\t=====*/\n\n\tvar evented = new Evented;\n\tvar emit = evented.emit;\n\tevented.emit = null;\n\t// Emit events asynchronously since they should not change the promise state.\n\tfunction emitAsync(args){\n\t\tsetTimeout(function(){\n\t\t\temit.apply(evented, args);\n\t\t}, 0);\n\t}\n\n\tPromise.prototype.trace = function(){\n\t\t// summary:\n\t\t//\t\tTrace the promise.\n\t\t// description:\n\t\t//\t\tTracing allows you to transparently log progress,\n\t\t//\t\tresolution and rejection of promises, without affecting the\n\t\t//\t\tpromise itself. Any arguments passed to `trace()` are\n\t\t//\t\temitted in trace events. See `dojo/promise/tracer` on how\n\t\t//\t\tto handle traces.\n\t\t// returns: dojo/promise/Promise\n\t\t//\t\tThe promise instance `trace()` is called on.\n\n\t\tvar args = lang._toArray(arguments);\n\t\tthis.then(\n\t\t\tfunction(value){ emitAsync([\"resolved\", value].concat(args)); },\n\t\t\tfunction(error){ emitAsync([\"rejected\", error].concat(args)); },\n\t\t\tfunction(update){ emitAsync([\"progress\", update].concat(args)); }\n\t\t);\n\t\treturn this;\n\t};\n\n\tPromise.prototype.traceRejected = function(){\n\t\t// summary:\n\t\t//\t\tTrace rejection of the promise.\n\t\t// description:\n\t\t//\t\tTracing allows you to transparently log progress,\n\t\t//\t\tresolution and rejection of promises, without affecting the\n\t\t//\t\tpromise itself. Any arguments passed to `trace()` are\n\t\t//\t\temitted in trace events. See `dojo/promise/tracer` on how\n\t\t//\t\tto handle traces.\n\t\t// returns: dojo/promise/Promise\n\t\t//\t\tThe promise instance `traceRejected()` is called on.\n\n\t\tvar args = lang._toArray(arguments);\n\t\tthis.otherwise(function(error){\n\t\t\temitAsync([\"rejected\", error].concat(args));\n\t\t});\n\t\treturn this;\n\t};\n\n\treturn evented;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/promise/tracer.js?");

/***/ }),

/***/ "./node_modules/dojox/lang/functional/fold.js":
/*!****************************************************!*\
  !*** ./node_modules/dojox/lang/functional/fold.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\"), __webpack_require__(/*! dojo/_base/kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! ./lambda */ \"./node_modules/dojox/lang/functional/lambda.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, arr, kernel, df){\n\n// This module adds high-level functions and related constructs:\n//\t- \"fold\" family of functions\n\n// Notes:\n//\t- missing high-level functions are provided with the compatible API:\n//\t\tfoldl, foldl1, foldr, foldr1\n//\t- missing JS standard functions are provided with the compatible API:\n//\t\treduce, reduceRight\n//\t- the fold's counterpart: unfold\n\n// Defined methods:\n//\t- take any valid lambda argument as the functional argument\n//\t- operate on dense arrays\n//\t- take a string as the array argument\n//\t- take an iterator objects as the array argument (only foldl, foldl1, and reduce)\n\n\tvar empty = {};\n\n\tlang.mixin(df, {\n\t\t// classic reduce-class functions\n\t\tfoldl: function(/*Array|String|Object*/ a, /*Function*/ f, /*Object*/ z, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\trepeatedly applies a binary function to an array from left\n\t\t\t//\t\tto right using a seed value as a starting point; returns the final\n\t\t\t//\t\tvalue.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar i, n;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tfor(i = 0, n = a.length; i < n; z = f.call(o, z, a[i], i, a), ++i);\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tfor(i = 0; a.hasNext(); z = f.call(o, z, a.next(), i++, a));\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tz = f.call(o, z, a[i], i, a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn z;\t// Object\n\t\t},\n\t\tfoldl1: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\trepeatedly applies a binary function to an array from left\n\t\t\t//\t\tto right; returns the final value.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar z, i, n;\n\t\t\tif(lang.isArray(a)){\n\t\t\t\t// array\n\t\t\t\tz = a[0];\n\t\t\t\tfor(i = 1, n = a.length; i < n; z = f.call(o, z, a[i], i, a), ++i);\n\t\t\t}else if(typeof a.hasNext == \"function\" && typeof a.next == \"function\"){\n\t\t\t\t// iterator\n\t\t\t\tif(a.hasNext()){\n\t\t\t\t\tz = a.next();\n\t\t\t\t\tfor(i = 1; a.hasNext(); z = f.call(o, z, a.next(), i++, a));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// object/dictionary\n\t\t\t\tvar first = true;\n\t\t\t\tfor(i in a){\n\t\t\t\t\tif(!(i in empty)){\n\t\t\t\t\t\tif(first){\n\t\t\t\t\t\t\tz = a[i];\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tz = f.call(o, z, a[i], i, a);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn z;\t// Object\n\t\t},\n\t\tfoldr: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object*/ z, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\trepeatedly applies a binary function to an array from right\n\t\t\t//\t\tto left using a seed value as a starting point; returns the final\n\t\t\t//\t\tvalue.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tfor(var i = a.length; i > 0; --i, z = f.call(o, z, a[i], i, a));\n\t\t\treturn z;\t// Object\n\t\t},\n\t\tfoldr1: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\trepeatedly applies a binary function to an array from right\n\t\t\t//\t\tto left; returns the final value.\n\t\t\tif(typeof a == \"string\"){ a = a.split(\"\"); }\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar n = a.length, z = a[n - 1], i = n - 1;\n\t\t\tfor(; i > 0; --i, z = f.call(o, z, a[i], i, a));\n\t\t\treturn z;\t// Object\n\t\t},\n\t\t// JS 1.8 standard array functions, which can take a lambda as a parameter.\n\t\treduce: function(/*Array|String|Object*/ a, /*Function|String|Array*/ f, /*Object?*/ z){\n\t\t\t// summary:\n\t\t\t//\t\tapply a function simultaneously against two values of the array\n\t\t\t//\t\t(from left-to-right) as to reduce it to a single value.\n\t\t\treturn arguments.length < 3 ? df.foldl1(a, f) : df.foldl(a, f, z);\t// Object\n\t\t},\n\t\treduceRight: function(/*Array|String*/ a, /*Function|String|Array*/ f, /*Object?*/ z){\n\t\t\t// summary:\n\t\t\t//\t\tapply a function simultaneously against two values of the array\n\t\t\t//\t\t(from right-to-left) as to reduce it to a single value.\n\t\t\treturn arguments.length < 3 ? df.foldr1(a, f) : df.foldr(a, f, z);\t// Object\n\t\t},\n\t\t// the fold's counterpart: unfold\n\t\tunfold: function(/*Function|String|Array*/ pr, /*Function|String|Array*/ f,\n\t\t\t\t\t\t/*Function|String|Array*/ g, /*Object*/ z, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tbuilds an array by unfolding a value\n\t\t\to = o || kernel.global; f = df.lambda(f); g = df.lambda(g); pr = df.lambda(pr);\n\t\t\tvar t = [];\n\t\t\tfor(; !pr.call(o, z); t.push(f.call(o, z)), z = g.call(o, z));\n\t\t\treturn t;\t// Array\n\t\t}\n\t});\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojox/lang/functional/fold.js?");

/***/ }),

/***/ "./node_modules/dojox/lang/functional/lambda.js":
/*!******************************************************!*\
  !*** ./node_modules/dojox/lang/functional/lambda.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../.. */ \"./node_modules/dojox/main.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! dojo/_base/array */ \"./node_modules/dojo/_base/array.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojox, lang, arr){\n\tvar df = lang.getObject(\"lang.functional\", true, dojox);\n\n// This module adds high-level functions and related constructs:\n//\t- anonymous functions built from the string\n\n// Acknowledgements:\n//\t- lambda() is based on work by Oliver Steele\n//\t\t(http://osteele.com/sources/javascript/functional/functional.js)\n//\t\twhich was published under MIT License\n\n// Notes:\n//\t- lambda() produces functions, which after the compilation step are\n//\t\tas fast as regular JS functions (at least theoretically).\n\n// Lambda input values:\n//\t- returns functions unchanged\n//\t- converts strings to functions\n//\t- converts arrays to a functional composition\n\n\tvar lcache = {};\n\n\t// split() is augmented on IE6 to ensure the uniform behavior\n\tvar split = \"ab\".split(/a*/).length > 1 ? String.prototype.split :\n\t\t\tfunction(sep){\n\t\t\t\t var r = this.split.call(this, sep),\n\t\t\t\t\t m = sep.exec(this);\n\t\t\t\t if(m && m.index == 0){ r.unshift(\"\"); }\n\t\t\t\t return r;\n\t\t\t};\n\t\t\t\n\tvar lambda = function(/*String*/ s){\n\t\tvar args = [], sects = split.call(s, /\\s*->\\s*/m);\n\t\tif(sects.length > 1){\n\t\t\twhile(sects.length){\n\t\t\t\ts = sects.pop();\n\t\t\t\targs = sects.pop().split(/\\s*,\\s*|\\s+/m);\n\t\t\t\tif(sects.length){ sects.push(\"(function(\" + args.join(\", \") + \"){ return (\" + s + \"); })\"); }\n\t\t\t}\n\t\t}else if(s.match(/\\b_\\b/)){\n\t\t\targs = [\"_\"];\n\t\t}else{\n\t\t\tvar l = s.match(/^\\s*(?:[+*\\/%&|\\^\\.=<>]|!=)/m),\n\t\t\t\tr = s.match(/[+\\-*\\/%&|\\^\\.=<>!]\\s*$/m);\n\t\t\tif(l || r){\n\t\t\t\tif(l){\n\t\t\t\t\targs.push(\"$1\");\n\t\t\t\t\ts = \"$1\" + s;\n\t\t\t\t}\n\t\t\t\tif(r){\n\t\t\t\t\targs.push(\"$2\");\n\t\t\t\t\ts = s + \"$2\";\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// the point of the long regex below is to exclude all well-known\n\t\t\t\t// lower-case words from the list of potential arguments\n\t\t\t\tvar vars = s.\n\t\t\t\t\treplace(/(?:\\b[A-Z]|\\.[a-zA-Z_$])[a-zA-Z_$\\d]*|[a-zA-Z_$][a-zA-Z_$\\d]*:|this|true|false|null|undefined|typeof|instanceof|in|delete|new|void|arguments|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|isFinite|isNaN|parseFloat|parseInt|unescape|dojo|dijit|dojox|window|document|'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"/g, \"\").\n\t\t\t\t\tmatch(/([a-z_$][a-z_$\\d]*)/gi) || [], t = {};\n\t\t\t\tarr.forEach(vars, function(v){\n\t\t\t\t\tif(!t.hasOwnProperty(v)){\n\t\t\t\t\t\targs.push(v);\n\t\t\t\t\t\tt[v] = 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn {args: args, body: s};\t// Object\n\t};\n\n\tvar compose = function(/*Array*/ a){\n\t\treturn a.length ?\n\t\t\t\t\tfunction(){\n\t\t\t\t\t\tvar i = a.length - 1, x = df.lambda(a[i]).apply(this, arguments);\n\t\t\t\t\t\tfor(--i; i >= 0; --i){ x = df.lambda(a[i]).call(this, x); }\n\t\t\t\t\t\treturn x;\n\t\t\t\t\t}\n\t\t\t\t:\n\t\t\t\t\t// identity\n\t\t\t\t\tfunction(x){ return x; };\n\t};\n\n\tlang.mixin(df, {\n\t\t// lambda\n\t\trawLambda: function(/*String*/ s){\n\t\t\t// summary:\n\t\t\t//\t\tbuilds a function from a snippet, or array (composing),\n\t\t\t//\t\treturns an object describing the function; functions are\n\t\t\t//\t\tpassed through unmodified.\n\t\t\t// description:\n\t\t\t//\t\tThis method is to normalize a functional representation (a\n\t\t\t//\t\ttext snippet) to an object that contains an array of\n\t\t\t//\t\targuments, and a body , which is used to calculate the\n\t\t\t//\t\treturning value.\n\t\t\treturn lambda(s);\t// Object\n\t\t},\n\t\tbuildLambda: function(/*String*/ s){\n\t\t\t// summary:\n\t\t\t//\t\tbuilds a function from a snippet, returns a string, which\n\t\t\t//\t\trepresents the function.\n\t\t\t// description:\n\t\t\t//\t\tThis method returns a textual representation of a function\n\t\t\t//\t\tbuilt from the snippet. It is meant to be evaled in the\n\t\t\t//\t\tproper context, so local variables can be pulled from the\n\t\t\t//\t\tenvironment.\n\t\t\tvar l = lambda(s);\n\t\t\treturn \"function(\" + l.args.join(\",\") + \"){return (\" + l.body + \");}\";\t// String\n\t\t},\n\t\tlambda: function(/*Function|String|Array*/ s){\n\t\t\t// summary:\n\t\t\t//\t\tbuilds a function from a snippet, or array (composing),\n\t\t\t//\t\treturns a function object; functions are passed through\n\t\t\t//\t\tunmodified.\n\t\t\t// description:\n\t\t\t//\t\tThis method is used to normalize a functional\n\t\t\t//\t\trepresentation (a text snippet, an array, or a function) to\n\t\t\t//\t\ta function object.\n\t\t\tif(typeof s == \"function\"){ return s; }\n\t\t\tif(s instanceof Array){ return compose(s); }\n\t\t\tif(lcache.hasOwnProperty(s)){ return lcache[s]; }\n\t\t\tvar l = lambda(s);\n\t\t\treturn lcache[s] = new Function(l.args, \"return (\" + l.body + \");\");\t// Function\n\t\t},\n\t\tclearLambdaCache: function(){\n\t\t\t// summary:\n\t\t\t//\t\tclears internal cache of lambdas\n\t\t\tlcache = {};\n\t\t}\n\t});\n\t\n\treturn df;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojox/lang/functional/lambda.js?");

/***/ }),

/***/ "./node_modules/dojox/lang/functional/object.js":
/*!******************************************************!*\
  !*** ./node_modules/dojox/lang/functional/object.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! dojo/_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! ./lambda */ \"./node_modules/dojox/lang/functional/lambda.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(kernel, lang, df){\n\n// This module adds high-level functions and related constructs:\n//\t- object/dictionary helpers\n\n// Defined methods:\n//\t- take any valid lambda argument as the functional argument\n//\t- skip all attributes that are present in the empty object\n//\t\t(IE and/or 3rd-party libraries).\n\n\tvar empty = {};\n\n\tlang.mixin(df, {\n\t\t// object helpers\n\t\tkeys: function(/*Object*/ obj){\n\t\t\t// summary:\n\t\t\t//\t\treturns an array of all keys in the object\n\t\t\tvar t = [];\n\t\t\tfor(var i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tt.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\tt; // Array\n\t\t},\n\t\tvalues: function(/*Object*/ obj){\n\t\t\t// summary:\n\t\t\t//\t\treturns an array of all values in the object\n\t\t\tvar t = [];\n\t\t\tfor(var i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tt.push(obj[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\tt; // Array\n\t\t},\n\t\tfilterIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tcreates new object with all attributes that pass the test\n\t\t\t//\t\timplemented by the provided function.\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar t = {}, v, i;\n\t\t\tfor(i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tv = obj[i];\n\t\t\t\t\tif(f.call(o, v, i, obj)){ t[i] = v; }\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn t;\t// Object\n\t\t},\n\t\tforIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\titerates over all object attributes.\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tfor(var i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tf.call(o, obj[i], i, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn o;\t// Object\n\t\t},\n\t\tmapIn: function(/*Object*/ obj, /*Function|String|Array*/ f, /*Object?*/ o){\n\t\t\t// summary:\n\t\t\t//\t\tcreates new object with the results of calling\n\t\t\t//\t\ta provided function on every attribute in this object.\n\t\t\to = o || kernel.global; f = df.lambda(f);\n\t\t\tvar t = {}, i;\n\t\t\tfor(i in obj){\n\t\t\t\tif(!(i in empty)){\n\t\t\t\t\tt[i] = f.call(o, obj[i], i, obj);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn t;\t// Object\n\t\t}\n\t});\n\t\n\treturn df;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojox/lang/functional/object.js?");

/***/ }),

/***/ "./node_modules/dojox/main.js":
/*!************************************!*\
  !*** ./node_modules/dojox/main.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! dojo/_base/kernel */ \"./node_modules/dojo/_base/kernel.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo) {\n\t// module:\n\t//\t\tdojox/main\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tThe dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.\n\t\t//\t\tApps should require modules from the dojox packages directly, rather than loading this module.\n\t};\n\t=====*/\n\n\treturn dojo.dojox;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./node_modules/dojox/main.js?");

/***/ }),

/***/ "./node_modules/punycode/punycode.js":
/*!*******************************************!*\
  !*** ./node_modules/punycode/punycode.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(null, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/punycode/punycode.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/querystring-es3/decode.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n//# sourceURL=webpack:///./node_modules/querystring-es3/encode.js?");

/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.decode = exports.parse = __webpack_require__(/*! ./decode */ \"./node_modules/querystring-es3/decode.js\");\nexports.encode = exports.stringify = __webpack_require__(/*! ./encode */ \"./node_modules/querystring-es3/encode.js\");\n\n\n//# sourceURL=webpack:///./node_modules/querystring-es3/index.js?");

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(/*! punycode */ \"./node_modules/punycode/punycode.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/url/util.js\");\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(/*! querystring */ \"./node_modules/querystring-es3/index.js\");\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\n\n//# sourceURL=webpack:///./node_modules/url/url.js?");

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/url/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ })

}]);