(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	"dojo/_base/array":"./node_modules/dojo/_base/array.js",
	"dojo/_base/config":"./node_modules/dojo/_base/config.js",
	"dojo/_base/declare":"./node_modules/dojo/_base/declare.js",
	"dojo/_base/kernel":"./node_modules/dojo/_base/kernel.js",
	"dojo/_base/lang":"./node_modules/dojo/_base/lang.js",
	"dojo/global":"./node_modules/dojo/global.js",
	"dojo/has":"./node_modules/dojo/has.js",
	"dojo/sniff":"./node_modules/dojo/sniff.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/dojo/_base/array.js":
/*!******************************************!*\
  !*** ./node_modules/dojo/_base/array.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! ./lang */ \"./node_modules/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, lang){\n\t// module:\n\t//\t\tdojo/_base/array\n\n\t// our old simple function builder stuff\n\tvar cache = {}, u;\n\n\tfunction buildFn(fn){\n\t\treturn cache[fn] = new Function(\"item\", \"index\", \"array\", fn); // Function\n\t}\n\t// magic snippet: if(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\n\t// every & some\n\n\tfunction everyOrSome(some){\n\t\tvar every = !some;\n\t\treturn function(a, fn, o){\n\t\t\tvar i = 0, l = a && a.length || 0, result;\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\t\tif(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\t\t\tif(o){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tresult = !fn.call(o, a[i], i, a);\n\t\t\t\t\tif(some ^ result){\n\t\t\t\t\t\treturn !result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tresult = !fn(a[i], i, a);\n\t\t\t\t\tif(some ^ result){\n\t\t\t\t\t\treturn !result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn every; // Boolean\n\t\t};\n\t}\n\n\t// indexOf, lastIndexOf\n\n\tfunction index(up){\n\t\tvar delta = 1, lOver = 0, uOver = 0;\n\t\tif(!up){\n\t\t\tdelta = lOver = uOver = -1;\n\t\t}\n\t\treturn function(a, x, from, last){\n\t\t\tif(last && delta > 0){\n\t\t\t\t// TODO: why do we use a non-standard signature? why do we need \"last\"?\n\t\t\t\treturn array.lastIndexOf(a, x, from);\n\t\t\t}\n\t\t\tvar l = a && a.length || 0, end = up ? l + uOver : lOver, i;\n\t\t\tif(from === u){\n\t\t\t\ti = up ? lOver : l + uOver;\n\t\t\t}else{\n\t\t\t\tif(from < 0){\n\t\t\t\t\ti = l + from;\n\t\t\t\t\tif(i < 0){\n\t\t\t\t\t\ti = lOver;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\ti = from >= l ? l + uOver : from;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\t\tfor(; i != end; i += delta){\n\t\t\t\tif(a[i] == x){\n\t\t\t\t\treturn i; // Number\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1; // Number\n\t\t};\n\t}\n\n\tvar array = {\n\t\t// summary:\n\t\t//\t\tThe Javascript v1.6 array extensions.\n\n\t\tevery: everyOrSome(false),\n\t\t/*=====\n\t\t every: function(arr, callback, thisObject){\n\t\t\t // summary:\n\t\t\t //\t\tDetermines whether or not every item in arr satisfies the\n\t\t\t //\t\tcondition implemented by callback.\n\t\t\t // arr: Array|String\n\t\t\t //\t\tthe array to iterate on. If a string, operates on individual characters.\n\t\t\t // callback: Function|String\n\t\t\t //\t\ta function is invoked with three arguments: item, index,\n\t\t\t //\t\tand array and returns true if the condition is met.\n\t\t\t // thisObject: Object?\n\t\t\t //\t\tmay be used to scope the call to callback\n\t\t\t // returns: Boolean\n\t\t\t // description:\n\t\t\t //\t\tThis function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\n\t\t\t //\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t //\t\tthe callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.\n\t\t\t //\t\tFor more details, see:\n\t\t\t //\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every\n\t\t\t // example:\n\t\t\t //\t|\t// returns false\n\t\t\t //\t|\tarray.every([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\t // example:\n\t\t\t //\t|\t// returns true\n\t\t\t //\t|\tarray.every([1, 2, 3, 4], function(item){ return item>0; });\n\t\t },\n\t\t =====*/\n\n\t\tsome: everyOrSome(true),\n\t\t/*=====\n\t\tsome: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tDetermines whether or not any item in arr satisfies the\n\t\t\t//\t\tcondition implemented by callback.\n\t\t\t// arr: Array|String\n\t\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function is invoked with three arguments: item, index,\n\t\t\t//\t\tand array and returns true if the condition is met.\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Boolean\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some\n\t\t\t// example:\n\t\t\t//\t| // is true\n\t\t\t//\t| array.some([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\t// example:\n\t\t\t//\t| // is false\n\t\t\t//\t| array.some([1, 2, 3, 4], function(item){ return item<1; });\n\t\t},\n\t\t=====*/\n\n\t\tindexOf: index(true),\n\t\t/*=====\n\t\tindexOf: function(arr, value, fromIndex, findLast){\n\t\t\t// summary:\n\t\t\t//\t\tlocates the first index of the provided value in the\n\t\t\t//\t\tpassed array. If the value is not found, -1 is returned.\n\t\t\t// description:\n\t\t\t//\t\tThis method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:\n\t\t\t//\n\t\t\t//\t\t1. when run over sparse arrays, the Dojo function invokes the callback for every index\n\t\t\t//\t\t   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.\n\t\t\t//\t\t2. uses equality (==) rather than strict equality (===)\n\t\t\t//\n\t\t\t//\t\tFor details on this method, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf\n\t\t\t// arr: Array\n\t\t\t// value: Object\n\t\t\t// fromIndex: Integer?\n\t\t\t// findLast: Boolean?\n\t\t\t//\t\tMakes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.\n\t\t\t// returns: Number\n\t\t},\n\t\t=====*/\n\n\t\tlastIndexOf: index(false),\n\t\t/*=====\n\t\tlastIndexOf: function(arr, value, fromIndex){\n\t\t\t// summary:\n\t\t\t//\t\tlocates the last index of the provided value in the passed\n\t\t\t//\t\tarray. If the value is not found, -1 is returned.\n\t\t\t// description:\n\t\t \t//\t\tThis method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:\n\t\t \t//\n\t\t \t//\t\t1. when run over sparse arrays, the Dojo function invokes the callback for every index\n\t\t \t//\t\t   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.\n\t\t \t//\t\t2. uses equality (==) rather than strict equality (===)\n\t\t \t//\n\t\t \t//\t\tFor details on this method, see:\n\t\t \t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf\n\t\t\t// arr: Array,\n\t\t\t// value: Object,\n\t\t\t// fromIndex: Integer?\n\t\t\t// returns: Number\n\t\t},\n\t\t=====*/\n\n\t\tforEach: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tfor every item in arr, callback is invoked. Return values are ignored.\n\t\t\t//\t\tIf you want to break out of the loop, consider using array.every() or array.some().\n\t\t\t//\t\tforEach does not allow breaking out of the loop over the items in arr.\n\t\t\t// arr:\n\t\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\t// callback:\n\t\t\t//\t\ta function is invoked with three arguments: item, index, and array\n\t\t\t// thisObject:\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\n\t\t\t// example:\n\t\t\t//\t| // log out all members of the array:\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tfunction(item){\n\t\t\t//\t|\t\t\tconsole.log(item);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| );\n\t\t\t// example:\n\t\t\t//\t| // log out the members and their indexes\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tfunction(item, idx, arr){\n\t\t\t//\t|\t\t\tconsole.log(item, \"at index:\", idx);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| );\n\t\t\t// example:\n\t\t\t//\t| // use a scoped object member as the callback\n\t\t\t//\t|\n\t\t\t//\t| var obj = {\n\t\t\t//\t|\t\tprefix: \"logged via obj.callback:\",\n\t\t\t//\t|\t\tcallback: function(item){\n\t\t\t//\t|\t\t\tconsole.log(this.prefix, item);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| };\n\t\t\t//\t|\n\t\t\t//\t| // specifying the scope function executes the callback in that scope\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tobj.callback,\n\t\t\t//\t|\t\tobj\n\t\t\t//\t| );\n\t\t\t//\t|\n\t\t\t//\t| // alternately, we can accomplish the same thing with lang.hitch()\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tlang.hitch(obj, \"callback\")\n\t\t\t//\t| );\n\t\t\t// arr: Array|String\n\t\t\t// callback: Function|String\n\t\t\t// thisObject: Object?\n\n\t\t\tvar i = 0, l = arr && arr.length || 0;\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tcallback.call(thisObject, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tcallback(arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmap: function(arr, callback, thisObject, Ctr){\n\t\t\t// summary:\n\t\t\t//\t\tapplies callback to each element of arr and returns\n\t\t\t//\t\tan Array with the results\n\t\t\t// arr: Array|String\n\t\t\t//\t\tthe array to iterate on. If a string, operates on\n\t\t\t//\t\tindividual characters.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function is invoked with three arguments, (item, index,\n\t\t\t//\t\tarray),\t and returns a value\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Array\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\n\t\t\t// example:\n\t\t\t//\t| // returns [2, 3, 4, 5]\n\t\t\t//\t| array.map([1, 2, 3, 4], function(item){ return item+1 });\n\n\t\t\t// TODO: why do we have a non-standard signature here? do we need \"Ctr\"?\n\t\t\tvar i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tout[i] = callback.call(thisObject, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tout[i] = callback(arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out; // Array\n\t\t},\n\n\t\tfilter: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new Array with those items from arr that match the\n\t\t\t//\t\tcondition implemented by callback.\n\t\t\t// arr: Array\n\t\t\t//\t\tthe array to iterate over.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function that is invoked with three arguments (item,\n\t\t\t//\t\tindex, array). The return of this function is expected to\n\t\t\t//\t\tbe a boolean which determines whether the passed-in item\n\t\t\t//\t\twill be included in the returned array.\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Array\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\n\t\t\t// example:\n\t\t\t//\t| // returns [2, 3, 4]\n\t\t\t//\t| array.filter([1, 2, 3, 4], function(item){ return item>1; });\n\n\t\t\t// TODO: do we need \"Ctr\" here like in map()?\n\t\t\tvar i = 0, l = arr && arr.length || 0, out = [], value;\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tvalue = arr[i];\n\t\t\t\t\tif(callback.call(thisObject, value, i, arr)){\n\t\t\t\t\t\tout.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tvalue = arr[i];\n\t\t\t\t\tif(callback(value, i, arr)){\n\t\t\t\t\t\tout.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out; // Array\n\t\t},\n\n\t\tclearCache: function(){\n\t\t\tcache = {};\n\t\t}\n\t};\n\n\n\thas(\"extend-dojo\") && lang.mixin(dojo, array);\n\n\treturn array;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/array.js?");

/***/ }),

/***/ "./node_modules/dojo/_base/config.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/_base/config.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../global */ \"./node_modules/dojo/global.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__.dj.c(module.i)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, has, require){\n\t// module:\n\t//\t\tdojo/_base/config\n\n/*=====\nreturn {\n\t// summary:\n\t//\t\tThis module defines the user configuration during bootstrap.\n\t// description:\n\t//\t\tBy defining user configuration as a module value, an entire configuration can be specified in a build,\n\t//\t\tthereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.\n\t//\t\tAlso, when multiple instances of dojo exist in a single application, each will necessarily be located\n\t//\t\tat an unique absolute module identifier as given by the package configuration. Implementing configuration\n\t//\t\tas a module allows for specifying unique, per-instance configurations.\n\t// example:\n\t//\t\tCreate a second instance of dojo with a different, instance-unique configuration (assume the loader and\n\t//\t\tdojo.js are already loaded).\n\t//\t\t|\t// specify a configuration that creates a new instance of dojo at the absolute module identifier \"myDojo\"\n\t//\t\t|\trequire({\n\t//\t\t|\t\tpackages:[{\n\t//\t\t|\t\t\tname:\"myDojo\",\n\t//\t\t|\t\t\tlocation:\".\", //assume baseUrl points to dojo.js\n\t//\t\t|\t\t}]\n\t//\t\t|\t});\n\t//\t\t|\n\t//\t\t|\t// specify a configuration for the myDojo instance\n\t//\t\t|\tdefine(\"myDojo/config\", {\n\t//\t\t|\t\t// normal configuration variables go here, e.g.,\n\t//\t\t|\t\tlocale:\"fr-ca\"\n\t//\t\t|\t});\n\t//\t\t|\n\t//\t\t|\t// load and use the new instance of dojo\n\t//\t\t|\trequire([\"myDojo\"], function(dojo){\n\t//\t\t|\t\t// dojo is the new instance of dojo\n\t//\t\t|\t\t// use as required\n\t//\t\t|\t});\n\n\t// isDebug: Boolean\n\t//\t\tDefaults to `false`. If set to `true`, ensures that Dojo provides\n\t//\t\textended debugging feedback to the console.\n\tisDebug: false,\n\n\t// locale: String\n\t//\t\tThe locale to assume for loading localized resources in this page,\n\t//\t\tspecified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).\n\t//\t\tMust be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.\n\t//\t\tSee the documentation for `dojo.i18n` and `dojo.requireLocalization`\n\t//\t\tfor details on loading localized resources. If no locale is specified,\n\t//\t\tDojo assumes the locale of the user agent, according to `navigator.userLanguage`\n\t//\t\tor `navigator.language` properties.\n\tlocale: undefined,\n\n\t// extraLocale: Array\n\t//\t\tNo default value. Specifies additional locales whose\n\t//\t\tresources should also be loaded alongside the default locale when\n\t//\t\tcalls to `dojo.requireLocalization()` are processed.\n\textraLocale: undefined,\n\n\t// baseUrl: String\n\t//\t\tThe directory in which `dojo.js` is located. Under normal\n\t//\t\tconditions, Dojo auto-detects the correct location from which it\n\t//\t\twas loaded. You may need to manually configure `baseUrl` in cases\n\t//\t\twhere you have renamed `dojo.js` or in which `<base>` tags confuse\n\t//\t\tsome browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned\n\t//\t\teither the value of `djConfig.baseUrl` if one is provided or the\n\t//\t\tauto-detected root if not. Other modules are located relative to\n\t//\t\tthis path. The path should end in a slash.\n\tbaseUrl: undefined,\n\n\t// modulePaths: [deprecated] Object\n\t//\t\tA map of module names to paths relative to `dojo.baseUrl`. The\n\t//\t\tkey/value pairs correspond directly to the arguments which\n\t//\t\t`dojo.registerModulePath` accepts. Specifying\n\t//\t\t`djConfig.modulePaths = { \"foo\": \"../../bar\" }` is the equivalent\n\t//\t\tof calling `dojo.registerModulePath(\"foo\", \"../../bar\");`. Multiple\n\t//\t\tmodules may be configured via `djConfig.modulePaths`.\n\tmodulePaths: {},\n\n\t// addOnLoad: Function|Array\n\t//\t\tAdds a callback via dojo/ready. Useful when Dojo is added after\n\t//\t\tthe page loads and djConfig.afterOnLoad is true. Supports the same\n\t//\t\targuments as dojo/ready. When using a function reference, use\n\t//\t\t`djConfig.addOnLoad = function(){};`. For object with function name use\n\t//\t\t`djConfig.addOnLoad = [myObject, \"functionName\"];` and for object with\n\t//\t\tfunction reference use\n\t//\t\t`djConfig.addOnLoad = [myObject, function(){}];`\n\taddOnLoad: null,\n\n\t// parseOnLoad: Boolean\n\t//\t\tRun the parser after the page is loaded\n\tparseOnLoad: false,\n\n\t// require: String[]\n\t//\t\tAn array of module names to be loaded immediately after dojo.js has been included\n\t//\t\tin a page.\n\trequire: [],\n\n\t// defaultDuration: Number\n\t//\t\tDefault duration, in milliseconds, for wipe and fade animations within dijits.\n\t//\t\tAssigned to dijit.defaultDuration.\n\tdefaultDuration: 200,\n\n\t// dojoBlankHtmlUrl: String\n\t//\t\tUsed by some modules to configure an empty iframe. Used by dojo/io/iframe and\n\t//\t\tdojo/back, and dijit/popup support in IE where an iframe is needed to make sure native\n\t//\t\tcontrols do not bleed through the popups. Normally this configuration variable\n\t//\t\tdoes not need to be set, except when using cross-domain/CDN Dojo builds.\n\t//\t\tSave dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`\n\t//\t\tto the path on your domain your copy of blank.html.\n\tdojoBlankHtmlUrl: undefined,\n\n\t// ioPublish: Boolean?\n\t//\t\tSet this to true to enable publishing of topics for the different phases of\n\t//\t\tIO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list\n\t//\t\tof topics that are published.\n\tioPublish: false,\n\n\t// transparentColor: Array\n\t//\t\tArray containing the r, g, b components used as transparent color in dojo.Color;\n\t//\t\tif undefined, [255,255,255] (white) will be used.\n\ttransparentColor: undefined,\n\t\n\t// deps: Function|Array\n\t//\t\tDefines dependencies to be used before the loader has been loaded.\n\t//\t\tWhen provided, they cause the loader to execute require(deps, callback) \n\t//\t\tonce it has finished loading. Should be used with callback.\n\tdeps: undefined,\n\t\n\t// callback: Function|Array\n\t//\t\tDefines a callback to be used when dependencies are defined before \n\t//\t\tthe loader has been loaded. When provided, they cause the loader to \n\t//\t\texecute require(deps, callback) once it has finished loading. \n\t//\t\tShould be used with deps.\n\tcallback: undefined,\n\t\n\t// deferredInstrumentation: Boolean\n\t//\t\tWhether deferred instrumentation should be loaded or included\n\t//\t\tin builds.\n\tdeferredInstrumentation: true,\n\n\t// useDeferredInstrumentation: Boolean|String\n\t//\t\tWhether the deferred instrumentation should be used.\n\t//\n\t//\t\t* `\"report-rejections\"`: report each rejection as it occurs.\n\t//\t\t* `true` or `1` or `\"report-unhandled-rejections\"`: wait 1 second\n\t//\t\t\tin an attempt to detect unhandled rejections.\n\tuseDeferredInstrumentation: \"report-unhandled-rejections\"\n};\n=====*/\n\n\tvar result = {};\n\tif(has(\"dojo-config-api\")){\n\t\t// must be the dojo loader; take a shallow copy of require.rawConfig\n\t\tvar src = require.rawConfig, p;\n\t\tfor(p in src){\n\t\t\tresult[p] = src[p];\n\t\t}\n\t}else{\n\t\tvar adviseHas = function(featureSet, prefix, booting){\n\t\t\tfor(p in featureSet){\n\t\t\t\tp!=\"has\" && has.add(prefix + p, featureSet[p], 0, booting);\n\t\t\t}\n\t\t};\n\t\tresult = has(\"dojo-loader\") ?\n\t\t\t// must be a built version of the dojo loader; all config stuffed in require.rawConfig\n\t\t\trequire.rawConfig :\n\t\t\t// a foreign loader\n\t\t\tglobal.dojoConfig || global.djConfig || {};\n\t\tadviseHas(result, \"config\", 1);\n\t\tadviseHas(result.has, \"\", 1);\n\t}\n\n\tif(!result.locale && typeof navigator != \"undefined\"){\n\t\t// Default locale for browsers (ensure it's read from user-settings not download locale).\n\t\tvar language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :\n\t\t\t(navigator.language || navigator.userLanguage);\n\t\tif(language){\n\t\t\tresult.locale = language.toLowerCase();\n\t\t}\n\t}\n\n\treturn result;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/config.js?");

/***/ }),

/***/ "./node_modules/dojo/_base/declare.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/_base/declare.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! ./lang */ \"./node_modules/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, lang){\n\t// module:\n\t//\t\tdojo/_base/declare\n\n\tvar mix = lang.mixin, op = Object.prototype, opts = op.toString,\n\t\txtor, counter = 0, cname = \"constructor\";\n\n\tif(!has(\"csp-restrictions\")){\n\t\t// 'new Function()' is preferable when available since it does not create a closure\n\t\txtor = new Function;\n\t}else{\n\t\txtor = function(){};\n\t}\n\n\tfunction err(msg, cls){ throw new Error(\"declare\" + (cls ? \" \" + cls : \"\") + \": \" + msg); }\n\n\t// C3 Method Resolution Order (see http://www.python.org/download/releases/2.3/mro/)\n\tfunction c3mro(bases, className){\n\t\tvar result = [], roots = [{cls: 0, refs: []}], nameMap = {}, clsCount = 1,\n\t\t\tl = bases.length, i = 0, j, lin, base, top, proto, rec, name, refs;\n\n\t\t// build a list of bases naming them if needed\n\t\tfor(; i < l; ++i){\n\t\t\tbase = bases[i];\n\t\t\tif(!base){\n\t\t\t\terr(\"mixin #\" + i + \" is unknown. Did you use dojo.require to pull it in?\", className);\n\t\t\t}else if(opts.call(base) != \"[object Function]\"){\n\t\t\t\terr(\"mixin #\" + i + \" is not a callable constructor.\", className);\n\t\t\t}\n\t\t\tlin = base._meta ? base._meta.bases : [base];\n\t\t\ttop = 0;\n\t\t\t// add bases to the name map\n\t\t\tfor(j = lin.length - 1; j >= 0; --j){\n\t\t\t\tproto = lin[j].prototype;\n\t\t\t\tif(!proto.hasOwnProperty(\"declaredClass\")){\n\t\t\t\t\tproto.declaredClass = \"uniqName_\" + (counter++);\n\t\t\t\t}\n\t\t\t\tname = proto.declaredClass;\n\t\t\t\tif(!nameMap.hasOwnProperty(name)){\n\t\t\t\t\tnameMap[name] = {count: 0, refs: [], cls: lin[j]};\n\t\t\t\t\t++clsCount;\n\t\t\t\t}\n\t\t\t\trec = nameMap[name];\n\t\t\t\tif(top && top !== rec){\n\t\t\t\t\trec.refs.push(top);\n\t\t\t\t\t++top.count;\n\t\t\t\t}\n\t\t\t\ttop = rec;\n\t\t\t}\n\t\t\t++top.count;\n\t\t\troots[0].refs.push(top);\n\t\t}\n\n\t\t// remove classes without external references recursively\n\t\twhile(roots.length){\n\t\t\ttop = roots.pop();\n\t\t\tresult.push(top.cls);\n\t\t\t--clsCount;\n\t\t\t// optimization: follow a single-linked chain\n\t\t\twhile(refs = top.refs, refs.length == 1){\n\t\t\t\ttop = refs[0];\n\t\t\t\tif(!top || --top.count){\n\t\t\t\t\t// branch or end of chain => do not end to roots\n\t\t\t\t\ttop = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresult.push(top.cls);\n\t\t\t\t--clsCount;\n\t\t\t}\n\t\t\tif(top){\n\t\t\t\t// branch\n\t\t\t\tfor(i = 0, l = refs.length; i < l; ++i){\n\t\t\t\t\ttop = refs[i];\n\t\t\t\t\tif(!--top.count){\n\t\t\t\t\t\troots.push(top);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(clsCount){\n\t\t\terr(\"can't build consistent linearization\", className);\n\t\t}\n\n\t\t// calculate the superclass offset\n\t\tbase = bases[0];\n\t\tresult[0] = base ?\n\t\t\tbase._meta && base === result[result.length - base._meta.bases.length] ?\n\t\t\t\tbase._meta.bases.length : 1 : 0;\n\n\t\treturn result;\n\t}\n\n\tfunction inherited(args, a, f, g){\n\t\tvar name, chains, bases, caller, meta, base, proto, opf, pos,\n\t\t\tcache = this._inherited = this._inherited || {};\n\n\t\t// crack arguments\n\t\tif(typeof args === \"string\"){\n\t\t\tname = args;\n\t\t\targs = a;\n\t\t\ta = f;\n\t\t\tf = g;\n\t\t}\n\n\t\tif(typeof args === \"function\"){\n\t\t\t// support strict mode\n\t\t\tcaller = args;\n\t\t\targs = a;\n\t\t\ta = f;\n\t\t}else{\n\t\t\ttry{\n\t\t\t\tcaller = args.callee;\n\t\t\t}catch (e){\n\t\t\t\tif(e instanceof TypeError){\n\t\t\t\t\t// caller was defined in a strict-mode context\n\t\t\t\t\terr(\"strict mode inherited() requires the caller function to be passed before arguments\", this.declaredClass);\n\t\t\t\t}else{\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tname = name || caller.nom;\n\t\tif(!name){\n\t\t\terr(\"can't deduce a name to call inherited()\", this.declaredClass);\n\t\t}\n\t\tf = g = 0;\n\n\t\tmeta = this.constructor._meta;\n\t\tbases = meta.bases;\n\n\t\tpos = cache.p;\n\t\tif(name != cname){\n\t\t\t// method\n\t\t\tif(cache.c !== caller){\n\t\t\t\t// cache bust\n\t\t\t\tpos = 0;\n\t\t\t\tbase = bases[0];\n\t\t\t\tmeta = base._meta;\n\t\t\t\tif(meta.hidden[name] !== caller){\n\t\t\t\t\t// error detection\n\t\t\t\t\tchains = meta.chains;\n\t\t\t\t\tif(chains && typeof chains[name] == \"string\"){\n\t\t\t\t\t\terr(\"calling chained method with inherited: \" + name, this.declaredClass);\n\t\t\t\t\t}\n\t\t\t\t\t// find caller\n\t\t\t\t\tdo{\n\t\t\t\t\t\tmeta = base._meta;\n\t\t\t\t\t\tproto = base.prototype;\n\t\t\t\t\t\tif(meta && (proto[name] === caller && proto.hasOwnProperty(name) || meta.hidden[name] === caller)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}while(base = bases[++pos]); // intentional assignment\n\t\t\t\t\tpos = base ? pos : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// find next\n\t\t\tbase = bases[++pos];\n\t\t\tif(base){\n\t\t\t\tproto = base.prototype;\n\t\t\t\tif(base._meta && proto.hasOwnProperty(name)){\n\t\t\t\t\tf = proto[name];\n\t\t\t\t}else{\n\t\t\t\t\topf = op[name];\n\t\t\t\t\tdo{\n\t\t\t\t\t\tproto = base.prototype;\n\t\t\t\t\t\tf = proto[name];\n\t\t\t\t\t\tif(f && (base._meta ? proto.hasOwnProperty(name) : f !== opf)){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}while(base = bases[++pos]); // intentional assignment\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = base && f || op[name];\n\t\t}else{\n\t\t\t// constructor\n\t\t\tif(cache.c !== caller){\n\t\t\t\t// cache bust\n\t\t\t\tpos = 0;\n\t\t\t\tmeta = bases[0]._meta;\n\t\t\t\tif(meta && meta.ctor !== caller){\n\t\t\t\t\t// error detection\n\t\t\t\t\tchains = meta.chains;\n\t\t\t\t\tif(!chains || chains.constructor !== \"manual\"){\n\t\t\t\t\t\terr(\"calling chained constructor with inherited\", this.declaredClass);\n\t\t\t\t\t}\n\t\t\t\t\t// find caller\n\t\t\t\t\twhile(base = bases[++pos]){ // intentional assignment\n\t\t\t\t\t\tmeta = base._meta;\n\t\t\t\t\t\tif(meta && meta.ctor === caller){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos = base ? pos : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// find next\n\t\t\twhile(base = bases[++pos]){\t// intentional assignment\n\t\t\t\tmeta = base._meta;\n\t\t\t\tf = meta ? meta.ctor : base;\n\t\t\t\tif(f){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf = base && f;\n\t\t}\n\n\t\t// cache the found super method\n\t\tcache.c = f;\n\t\tcache.p = pos;\n\n\t\t// now we have the result\n\t\tif(f){\n\t\t\treturn a === true ? f : f.apply(this, a || args);\n\t\t}\n\t\t// intentionally no return if a super method was not found\n\t}\n\n\tfunction getInherited(name, args, a){\n\t\tif(typeof name === \"string\"){\n\t\t\tif (typeof args === \"function\") {\n\t\t\t\treturn this.__inherited(name, args, a, true);\n\t\t\t}\n\t\t\treturn this.__inherited(name, args, true);\n\t\t}\n\t\telse if (typeof name === \"function\") {\n\t\t\treturn this.__inherited(name, args, true);\n\t\t}\n\t\treturn this.__inherited(name, true);\n\t}\n\n\tfunction inherited__debug(args, a1, a2, a3){\n\t\tvar f = this.getInherited(args, a1, a2);\n\t\tif(f){\n\t\t\treturn f.apply(this, a3 || a2 || a1 || args);\n\t\t}\n\t\t// intentionally no return if a super method was not found\n\t}\n\n\tvar inheritedImpl = dojo.config.isDebug ? inherited__debug : inherited;\n\n\t// emulation of \"instanceof\"\n\tfunction isInstanceOf(cls){\n\t\tvar bases = this.constructor._meta.bases;\n\t\tfor(var i = 0, l = bases.length; i < l; ++i){\n\t\t\tif(bases[i] === cls){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn this instanceof cls;\n\t}\n\n\tfunction mixOwn(target, source){\n\t\t// add props adding metadata for incoming functions skipping a constructor\n\t\tfor(var name in source){\n\t\t\tif(name != cname && source.hasOwnProperty(name)){\n\t\t\t\ttarget[name] = source[name];\n\t\t\t}\n\t\t}\n\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\tfor(var extraNames= lang._extraNames, i= extraNames.length; i;){\n\t\t\t\tname = extraNames[--i];\n\t\t\t\tif(name != cname && source.hasOwnProperty(name)){\n\t\t\t\t\t  target[name] = source[name];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// implementation of safe mixin function\n\tfunction safeMixin(target, source){\n\t\t// summary:\n\t\t//\t\tMix in properties skipping a constructor and decorating functions\n\t\t//\t\tlike it is done by declare().\n\t\t// target: Object\n\t\t//\t\tTarget object to accept new properties.\n\t\t// source: Object\n\t\t//\t\tSource object for new properties.\n\t\t// description:\n\t\t//\t\tThis function is used to mix in properties like lang.mixin does,\n\t\t//\t\tbut it skips a constructor property and decorates functions like\n\t\t//\t\tdeclare() does.\n\t\t//\n\t\t//\t\tIt is meant to be used with classes and objects produced with\n\t\t//\t\tdeclare. Functions mixed in with dojo.safeMixin can use\n\t\t//\t\tthis.inherited() like normal methods.\n\t\t//\n\t\t//\t\tThis function is used to implement extend() method of a constructor\n\t\t//\t\tproduced with declare().\n\t\t//\n\t\t// example:\n\t\t//\t|\tvar A = declare(null, {\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.m1\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar B = declare(A, {\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"B.m1\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tB.extend({\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"B.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar x = new B();\n\t\t//\t|\tdojo.safeMixin(x, {\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"X.m1\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"X.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tx.m2();\n\t\t//\t|\t// prints:\n\t\t//\t|\t// A.m1\n\t\t//\t|\t// B.m1\n\t\t//\t|\t// X.m1\n\n\t\tvar name, t;\n\t\t// add props adding metadata for incoming functions skipping a constructor\n\t\tfor(name in source){\n\t\t\tt = source[name];\n\t\t\tif((t !== op[name] || !(name in op)) && name != cname){\n\t\t\t\tif(opts.call(t) == \"[object Function]\"){\n\t\t\t\t\t// non-trivial function method => attach its name\n\t\t\t\t\tt.nom = name;\n\t\t\t\t}\n\t\t\t\ttarget[name] = t;\n\t\t\t}\n\t\t}\n\t\tif(has(\"bug-for-in-skips-shadowed\") && source){\n\t\t\tfor(var extraNames= lang._extraNames, i= extraNames.length; i;){\n\t\t\t\tname = extraNames[--i];\n\t\t\t\tt = source[name];\n\t\t\t\tif((t !== op[name] || !(name in op)) && name != cname){\n\t\t\t\t\tif(opts.call(t) == \"[object Function]\"){\n\t\t\t\t\t\t// non-trivial function method => attach its name\n\t\t\t\t\t\t  t.nom = name;\n\t\t\t\t\t}\n\t\t\t\t\ttarget[name] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn target;\n\t}\n\n\tfunction extend(source){\n\t\tdeclare.safeMixin(this.prototype, source);\n\t\treturn this;\n\t}\n\n\tfunction createSubclass(mixins, props){\n\t\t// crack parameters\n\t\tif(!(mixins instanceof Array || typeof mixins === 'function')){\n\t\t\tprops = mixins;\n\t\t\tmixins = undefined;\n\t\t}\n\n\t\tprops = props || {};\n\t\tmixins = mixins || [];\n\n\t\treturn declare([this].concat(mixins), props);\n\t}\n\n\t// chained constructor compatible with the legacy declare()\n\tfunction chainedConstructor(bases, ctorSpecial){\n\t\treturn function(){\n\t\t\tvar a = arguments, args = a, a0 = a[0], f, i, m,\n\t\t\t\tl = bases.length, preArgs;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t// not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t//this._inherited = {};\n\t\t\t// perform the shaman's rituals of the original declare()\n\t\t\t// 1) call two types of the preamble\n\t\t\tif(ctorSpecial && (a0 && a0.preamble || this.preamble)){\n\t\t\t\t// full blown ritual\n\t\t\t\tpreArgs = new Array(bases.length);\n\t\t\t\t// prepare parameters\n\t\t\t\tpreArgs[0] = a;\n\t\t\t\tfor(i = 0;;){\n\t\t\t\t\t// process the preamble of the 1st argument\n\t\t\t\t\ta0 = a[0];\n\t\t\t\t\tif(a0){\n\t\t\t\t\t\tf = a0.preamble;\n\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\ta = f.apply(this, a) || a;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// process the preamble of this class\n\t\t\t\t\tf = bases[i].prototype;\n\t\t\t\t\tf = f.hasOwnProperty(\"preamble\") && f.preamble;\n\t\t\t\t\tif(f){\n\t\t\t\t\t\ta = f.apply(this, a) || a;\n\t\t\t\t\t}\n\t\t\t\t\t// one peculiarity of the preamble:\n\t\t\t\t\t// it is called if it is not needed,\n\t\t\t\t\t// e.g., there is no constructor to call\n\t\t\t\t\t// let's watch for the last constructor\n\t\t\t\t\t// (see ticket #9795)\n\t\t\t\t\tif(++i == l){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpreArgs[i] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2) call all non-trivial constructors using prepared arguments\n\t\t\tfor(i = l - 1; i >= 0; --i){\n\t\t\t\tf = bases[i];\n\t\t\t\tm = f._meta;\n\t\t\t\tf = m ? m.ctor : f;\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, preArgs ? preArgs[i] : a);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 3) continue the original ritual: call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, args);\n\t\t\t}\n\t\t};\n\t}\n\n\n\t// chained constructor compatible with the legacy declare()\n\tfunction singleConstructor(ctor, ctorSpecial){\n\t\treturn function(){\n\t\t\tvar a = arguments, t = a, a0 = a[0], f;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t// not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t//this._inherited = {};\n\t\t\t// perform the shaman's rituals of the original declare()\n\t\t\t// 1) call two types of the preamble\n\t\t\tif(ctorSpecial){\n\t\t\t\t// full blown ritual\n\t\t\t\tif(a0){\n\t\t\t\t\t// process the preamble of the 1st argument\n\t\t\t\t\tf = a0.preamble;\n\t\t\t\t\tif(f){\n\t\t\t\t\t\tt = f.apply(this, t) || t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf = this.preamble;\n\t\t\t\tif(f){\n\t\t\t\t\t// process the preamble of this class\n\t\t\t\t\tf.apply(this, t);\n\t\t\t\t\t// one peculiarity of the preamble:\n\t\t\t\t\t// it is called even if it is not needed,\n\t\t\t\t\t// e.g., there is no constructor to call\n\t\t\t\t\t// let's watch for the last constructor\n\t\t\t\t\t// (see ticket #9795)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2) call a constructor\n\t\t\tif(ctor){\n\t\t\t\tctor.apply(this, a);\n\t\t\t}\n\t\t\t// 3) continue the original ritual: call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, a);\n\t\t\t}\n\t\t};\n\t}\n\n\t// plain vanilla constructor (can use inherited() to call its base constructor)\n\tfunction simpleConstructor(bases){\n\t\treturn function(){\n\t\t\tvar a = arguments, i = 0, f, m;\n\n\t\t\tif(!(this instanceof a.callee)){\n\t\t\t\t// not called via new, so force it\n\t\t\t\treturn applyNew(a);\n\t\t\t}\n\n\t\t\t//this._inherited = {};\n\t\t\t// perform the shaman's rituals of the original declare()\n\t\t\t// 1) do not call the preamble\n\t\t\t// 2) call the top constructor (it can use this.inherited())\n\t\t\tfor(; f = bases[i]; ++i){ // intentional assignment\n\t\t\t\tm = f._meta;\n\t\t\t\tf = m ? m.ctor : f;\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 3) call the postscript\n\t\t\tf = this.postscript;\n\t\t\tif(f){\n\t\t\t\tf.apply(this, a);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction chain(name, bases, reversed){\n\t\treturn function(){\n\t\t\tvar b, m, f, i = 0, step = 1;\n\t\t\tif(reversed){\n\t\t\t\ti = bases.length - 1;\n\t\t\t\tstep = -1;\n\t\t\t}\n\t\t\tfor(; b = bases[i]; i += step){ // intentional assignment\n\t\t\t\tm = b._meta;\n\t\t\t\tf = (m ? m.hidden : b.prototype)[name];\n\t\t\t\tif(f){\n\t\t\t\t\tf.apply(this, arguments);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// forceNew(ctor)\n\t// return a new object that inherits from ctor.prototype but\n\t// without actually running ctor on the object.\n\tfunction forceNew(ctor){\n\t\t// create object with correct prototype using a do-nothing\n\t\t// constructor\n\t\txtor.prototype = ctor.prototype;\n\t\tvar t = new xtor;\n\t\txtor.prototype = null;\t// clean up\n\t\treturn t;\n\t}\n\n\t// applyNew(args)\n\t// just like 'new ctor()' except that the constructor and its arguments come\n\t// from args, which must be an array or an arguments object\n\tfunction applyNew(args){\n\t\t// create an object with ctor's prototype but without\n\t\t// calling ctor on it.\n\t\tvar ctor = args.callee, t = forceNew(ctor);\n\t\t// execute the real constructor on the new object\n\t\tctor.apply(t, args);\n\t\treturn t;\n\t}\n\n\tfunction declare(className, superclass, props){\n\t\t// summary:\n\t\t//\t\tCreate a feature-rich constructor from compact notation.\n\t\t// className: String?\n\t\t//\t\tThe optional name of the constructor (loosely, a \"class\")\n\t\t//\t\tstored in the \"declaredClass\" property in the created prototype.\n\t\t//\t\tIt will be used as a global name for a created constructor.\n\t\t// superclass: Function|Function[]\n\t\t//\t\tMay be null, a Function, or an Array of Functions. This argument\n\t\t//\t\tspecifies a list of bases (the left-most one is the most deepest\n\t\t//\t\tbase).\n\t\t// props: Object\n\t\t//\t\tAn object whose properties are copied to the created prototype.\n\t\t//\t\tAdd an instance-initialization function by making it a property\n\t\t//\t\tnamed \"constructor\".\n\t\t// returns: dojo/_base/declare.__DeclareCreatedObject\n\t\t//\t\tNew constructor function.\n\t\t// description:\n\t\t//\t\tCreate a constructor using a compact notation for inheritance and\n\t\t//\t\tprototype extension.\n\t\t//\n\t\t//\t\tMixin ancestors provide a type of multiple inheritance.\n\t\t//\t\tPrototypes of mixin ancestors are copied to the new class:\n\t\t//\t\tchanges to mixin prototypes will not affect classes to which\n\t\t//\t\tthey have been mixed in.\n\t\t//\n\t\t//\t\tAncestors can be compound classes created by this version of\n\t\t//\t\tdeclare(). In complex cases all base classes are going to be\n\t\t//\t\tlinearized according to C3 MRO algorithm\n\t\t//\t\t(see http://www.python.org/download/releases/2.3/mro/ for more\n\t\t//\t\tdetails).\n\t\t//\n\t\t//\t\t\"className\" is cached in \"declaredClass\" property of the new class,\n\t\t//\t\tif it was supplied. The immediate super class will be cached in\n\t\t//\t\t\"superclass\" property of the new class.\n\t\t//\n\t\t//\t\tMethods in \"props\" will be copied and modified: \"nom\" property\n\t\t//\t\t(the declared name of the method) will be added to all copied\n\t\t//\t\tfunctions to help identify them for the internal machinery. Be\n\t\t//\t\tvery careful, while reusing methods: if you use the same\n\t\t//\t\tfunction under different names, it can produce errors in some\n\t\t//\t\tcases.\n\t\t//\n\t\t//\t\tIt is possible to use constructors created \"manually\" (without\n\t\t//\t\tdeclare()) as bases. They will be called as usual during the\n\t\t//\t\tcreation of an instance, their methods will be chained, and even\n\t\t//\t\tcalled by \"this.inherited()\".\n\t\t//\n\t\t//\t\tSpecial property \"-chains-\" governs how to chain methods. It is\n\t\t//\t\ta dictionary, which uses method names as keys, and hint strings\n\t\t//\t\tas values. If a hint string is \"after\", this method will be\n\t\t//\t\tcalled after methods of its base classes. If a hint string is\n\t\t//\t\t\"before\", this method will be called before methods of its base\n\t\t//\t\tclasses.\n\t\t//\n\t\t//\t\tIf \"constructor\" is not mentioned in \"-chains-\" property, it will\n\t\t//\t\tbe chained using the legacy mode: using \"after\" chaining,\n\t\t//\t\tcalling preamble() method before each constructor, if available,\n\t\t//\t\tand calling postscript() after all constructors were executed.\n\t\t//\t\tIf the hint is \"after\", it is chained as a regular method, but\n\t\t//\t\tpostscript() will be called after the chain of constructors.\n\t\t//\t\t\"constructor\" cannot be chained \"before\", but it allows\n\t\t//\t\ta special hint string: \"manual\", which means that constructors\n\t\t//\t\tare not going to be chained in any way, and programmer will call\n\t\t//\t\tthem manually using this.inherited(). In the latter case\n\t\t//\t\tpostscript() will be called after the construction.\n\t\t//\n\t\t//\t\tAll chaining hints are \"inherited\" from base classes and\n\t\t//\t\tpotentially can be overridden. Be very careful when overriding\n\t\t//\t\thints! Make sure that all chained methods can work in a proposed\n\t\t//\t\tmanner of chaining.\n\t\t//\n\t\t//\t\tOnce a method was chained, it is impossible to unchain it. The\n\t\t//\t\tonly exception is \"constructor\". You don't need to define a\n\t\t//\t\tmethod in order to supply a chaining hint.\n\t\t//\n\t\t//\t\tIf a method is chained, it cannot use this.inherited() because\n\t\t//\t\tall other methods in the hierarchy will be called automatically.\n\t\t//\n\t\t//\t\tUsually constructors and initializers of any kind are chained\n\t\t//\t\tusing \"after\" and destructors of any kind are chained as\n\t\t//\t\t\"before\". Note that chaining assumes that chained methods do not\n\t\t//\t\treturn any value: any returned value will be discarded.\n\t\t//\n\t\t// example:\n\t\t//\t|\tdeclare(\"my.classes.bar\", my.classes.foo, {\n\t\t//\t|\t\t// properties to be added to the class prototype\n\t\t//\t|\t\tsomeValue: 2,\n\t\t//\t|\t\t// initialization function\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\tthis.myComplicatedObject = new ReallyComplicatedObject();\n\t\t//\t|\t\t},\n\t\t//\t|\t\t// other functions\n\t\t//\t|\t\tsomeMethod: function(){\n\t\t//\t|\t\t\tdoStuff();\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t|\tvar MyBase = declare(null, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar MyClass1 = declare(MyBase, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar MyClass2 = declare(MyBase, {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\t|\tvar MyDiamond = declare([MyClass1, MyClass2], {\n\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t//\t|\t\t// ...\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t|\tvar F = function(){ console.log(\"raw constructor\"); };\n\t\t//\t|\tF.prototype.method = function(){\n\t\t//\t|\t\tconsole.log(\"raw method\");\n\t\t//\t|\t};\n\t\t//\t|\tvar A = declare(F, {\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.constructor\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tmethod: function(){\n\t\t//\t|\t\t\tconsole.log(\"before calling F.method...\");\n\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t//\t|\t\t\tconsole.log(\"...back in A\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tnew A().method();\n\t\t//\t|\t// will print:\n\t\t//\t|\t// raw constructor\n\t\t//\t|\t// A.constructor\n\t\t//\t|\t// before calling F.method...\n\t\t//\t|\t// raw method\n\t\t//\t|\t// ...back in A\n\t\t//\n\t\t// example:\n\t\t//\t|\tvar A = declare(null, {\n\t\t//\t|\t\t\"-chains-\": {\n\t\t//\t|\t\t\tdestroy: \"before\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar B = declare(A, {\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\tconsole.log(\"B.constructor\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tdestroy: function(){\n\t\t//\t|\t\t\tconsole.log(\"B.destroy\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar C = declare(B, {\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\tconsole.log(\"C.constructor\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tdestroy: function(){\n\t\t//\t|\t\t\tconsole.log(\"C.destroy\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tnew C().destroy();\n\t\t//\t|\t// prints:\n\t\t//\t|\t// B.constructor\n\t\t//\t|\t// C.constructor\n\t\t//\t|\t// C.destroy\n\t\t//\t|\t// B.destroy\n\t\t//\n\t\t// example:\n\t\t//\t|\tvar A = declare(null, {\n\t\t//\t|\t\t\"-chains-\": {\n\t\t//\t|\t\t\tconstructor: \"manual\"\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar B = declare(A, {\n\t\t//\t|\t\tconstructor: function(){\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t\t// call the base constructor with new parameters\n\t\t//\t|\t\t\tthis.inherited(arguments, [1, 2, 3]);\n\t\t//\t|\t\t\t// ...\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\n\t\t// example:\n\t\t//\t|\tvar A = declare(null, {\n\t\t//\t|\t\t\"-chains-\": {\n\t\t//\t|\t\t\tm1: \"before\"\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.m1\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tconsole.log(\"A.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar B = declare(A, {\n\t\t//\t|\t\t\"-chains-\": {\n\t\t//\t|\t\t\tm2: \"after\"\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm1: function(){\n\t\t//\t|\t\t\tconsole.log(\"B.m1\");\n\t\t//\t|\t\t},\n\t\t//\t|\t\tm2: function(){\n\t\t//\t|\t\t\tconsole.log(\"B.m2\");\n\t\t//\t|\t\t}\n\t\t//\t|\t});\n\t\t//\t|\tvar x = new B();\n\t\t//\t|\tx.m1();\n\t\t//\t|\t// prints:\n\t\t//\t|\t// B.m1\n\t\t//\t|\t// A.m1\n\t\t//\t|\tx.m2();\n\t\t//\t|\t// prints:\n\t\t//\t|\t// A.m2\n\t\t//\t|\t// B.m2\n\n\t\t// crack parameters\n\t\tif(typeof className != \"string\"){\n\t\t\tprops = superclass;\n\t\t\tsuperclass = className;\n\t\t\tclassName = \"\";\n\t\t}\n\t\tprops = props || {};\n\n\t\tvar proto, i, t, ctor, name, bases, chains, mixins = 1, parents = superclass;\n\n\t\t// build a prototype\n\t\tif(opts.call(superclass) == \"[object Array]\"){\n\t\t\t// C3 MRO\n\t\t\tbases = c3mro(superclass, className);\n\t\t\tt = bases[0];\n\t\t\tmixins = bases.length - t;\n\t\t\tsuperclass = bases[mixins];\n\t\t}else{\n\t\t\tbases = [0];\n\t\t\tif(superclass){\n\t\t\t\tif(opts.call(superclass) == \"[object Function]\"){\n\t\t\t\t\tt = superclass._meta;\n\t\t\t\t\tbases = bases.concat(t ? t.bases : superclass);\n\t\t\t\t}else{\n\t\t\t\t\terr(\"base class is not a callable constructor.\", className);\n\t\t\t\t}\n\t\t\t}else if(superclass !== null){\n\t\t\t\terr(\"unknown base class. Did you use dojo.require to pull it in?\", className);\n\t\t\t}\n\t\t}\n\t\tif(superclass){\n\t\t\tfor(i = mixins - 1;; --i){\n\t\t\t\tproto = forceNew(superclass);\n\t\t\t\tif(!i){\n\t\t\t\t\t// stop if nothing to add (the last base)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// mix in properties\n\t\t\t\tt = bases[i];\n\t\t\t\t(t._meta ? mixOwn : mix)(proto, t.prototype);\n\t\t\t\t// chain in new constructor\n\t\t\t\tif (has(\"csp-restrictions\")) {\n\t\t\t\t\tctor = function () {};\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tctor = new Function;\n\t\t\t\t}\n\t\t\t\tctor.superclass = superclass;\n\t\t\t\tctor.prototype = proto;\n\t\t\t\tsuperclass = proto.constructor = ctor;\n\t\t\t}\n\t\t}else{\n\t\t\tproto = {};\n\t\t}\n\t\t// add all properties\n\t\tdeclare.safeMixin(proto, props);\n\t\t// add constructor\n\t\tt = props.constructor;\n\t\tif(t !== op.constructor){\n\t\t\tt.nom = cname;\n\t\t\tproto.constructor = t;\n\t\t}\n\n\t\t// collect chains and flags\n\t\tfor(i = mixins - 1; i; --i){ // intentional assignment\n\t\t\tt = bases[i]._meta;\n\t\t\tif(t && t.chains){\n\t\t\t\tchains = mix(chains || {}, t.chains);\n\t\t\t}\n\t\t}\n\t\tif(proto[\"-chains-\"]){\n\t\t\tchains = mix(chains || {}, proto[\"-chains-\"]);\n\t\t}\n\n\t\tif(superclass && superclass.prototype && superclass.prototype[\"-chains-\"]) {\n\t\t\tchains = mix(chains || {}, superclass.prototype[\"-chains-\"]);\n\t\t}\n\n\t\t// build ctor\n\t\tt = !chains || !chains.hasOwnProperty(cname);\n\t\tbases[0] = ctor = (chains && chains.constructor === \"manual\") ? simpleConstructor(bases) :\n\t\t\t(bases.length == 1 ? singleConstructor(props.constructor, t) : chainedConstructor(bases, t));\n\n\t\t// add meta information to the constructor\n\t\tctor._meta  = {bases: bases, hidden: props, chains: chains,\n\t\t\tparents: parents, ctor: props.constructor};\n\t\tctor.superclass = superclass && superclass.prototype;\n\t\tctor.extend = extend;\n\t\tctor.createSubclass = createSubclass;\n\t\tctor.prototype = proto;\n\t\tproto.constructor = ctor;\n\n\t\t// add \"standard\" methods to the prototype\n\t\tproto.getInherited = getInherited;\n\t\tproto.isInstanceOf = isInstanceOf;\n\t\tproto.inherited    = inheritedImpl;\n\t\tproto.__inherited  = inherited;\n\n\t\t// add name if specified\n\t\tif(className){\n\t\t\tproto.declaredClass = className;\n\t\t\tlang.setObject(className, ctor);\n\t\t}\n\n\t\t// build chains and add them to the prototype\n\t\tif(chains){\n\t\t\tfor(name in chains){\n\t\t\t\tif(proto[name] && typeof chains[name] == \"string\" && name != cname){\n\t\t\t\t\tt = proto[name] = chain(name, bases, chains[name] === \"after\");\n\t\t\t\t\tt.nom = name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// chained methods do not return values\n\t\t// no need to chain \"invisible\" functions\n\n\t\treturn ctor;\t// Function\n\t}\n\n\t/*=====\n\tdeclare.__DeclareCreatedObject = {\n\t\t// summary:\n\t\t//\t\tdojo/_base/declare() returns a constructor `C`.   `new C()` returns an Object with the following\n\t\t//\t\tmethods, in addition to the methods and properties specified via the arguments passed to declare().\n\n\t\tinherited: function(name, caller, args, newArgs){\n\t\t\t// summary:\n\t\t\t//\t\tCalls a super method.\n\t\t\t// name: String?\n\t\t\t//\t\tThe optional method name. Should be the same as the caller's\n\t\t\t//\t\tname. Usually \"name\" is specified in complex dynamic cases, when\n\t\t\t//\t\tthe calling method was dynamically added, undecorated by\n\t\t\t//\t\tdeclare(), and it cannot be determined.\n\t\t\t// caller: Function?\n\t\t\t//\t\tThe reference to the calling function. Required only if the\n\t\t\t//\t\tcall to \"this.inherited\" occurs from within strict-mode code.\n\t\t\t//\t\tIf the caller is omitted within strict-mode code, an error will\n\t\t\t//\t\tbe thrown.\n\t\t\t//\t\tThe best way to obtain a reference to the calling function is to\n\t\t\t//\t\tuse a named function expression (i.e. place a function name\n\t\t\t//\t\tafter the \"function\" keyword and before the open paren, as in\n\t\t\t//\t\t\"function fn(a, b)\"). If the function is parsed as an expression\n\t\t\t//\t\tand not a statement (i.e. it's not by itself on its own line),\n\t\t\t//\t\tthe function name will only be accessible as an identifier from\n\t\t\t//\t\twithin the body of the function.\n\t\t\t// args: Arguments\n\t\t\t//\t\tThe caller supply this argument, which should be the original\n\t\t\t//\t\t\"arguments\".\n\t\t\t// newArgs: Object?\n\t\t\t//\t\tIf \"true\", the found function will be returned without\n\t\t\t//\t\texecuting it.\n\t\t\t//\t\tIf Array, it will be used to call a super method. Otherwise\n\t\t\t//\t\t\"args\" will be used.\n\t\t\t// returns:\n\t\t\t//\t\tWhatever is returned by a super method, or a super method itself,\n\t\t\t//\t\tif \"true\" was specified as newArgs.\n\t\t\t// description:\n\t\t\t//\t\tThis method is used inside method of classes produced with\n\t\t\t//\t\tdeclare() to call a super method (next in the chain). It is\n\t\t\t//\t\tused for manually controlled chaining. Consider using the regular\n\t\t\t//\t\tchaining, because it is faster. Use \"this.inherited()\" only in\n\t\t\t//\t\tcomplex cases.\n\t\t\t//\n\t\t\t//\t\tThis method cannot me called from automatically chained\n\t\t\t//\t\tconstructors including the case of a special (legacy)\n\t\t\t//\t\tconstructor chaining. It cannot be called from chained methods.\n\t\t\t//\n\t\t\t//\t\tIf \"this.inherited()\" cannot find the next-in-chain method, it\n\t\t\t//\t\tdoes nothing and returns \"undefined\". The last method in chain\n\t\t\t//\t\tcan be a default method implemented in Object, which will be\n\t\t\t//\t\tcalled last.\n\t\t\t//\n\t\t\t//\t\tIf \"name\" is specified, it is assumed that the method that\n\t\t\t//\t\treceived \"args\" is the parent method for this call. It is looked\n\t\t\t//\t\tup in the chain list and if it is found the next-in-chain method\n\t\t\t//\t\tis called. If it is not found, the first-in-chain method is\n\t\t\t//\t\tcalled.\n\t\t\t//\n\t\t\t//\t\tIf \"name\" is not specified, it will be derived from the calling\n\t\t\t//\t\tmethod (using a methoid property \"nom\").\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\tvar B = declare(A, {\n\t\t\t//\t|\t\tmethod1: function(a, b, c){\n\t\t\t//\t|\t\t\tthis.inherited(arguments);\n\t\t\t//\t|\t\t},\n\t\t\t//\t|\t\tmethod2: function(a, b){\n\t\t\t//\t|\t\t\treturn this.inherited(arguments, [a + b]);\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t});\n\t\t\t//\t|\t// next method is not in the chain list because it is added\n\t\t\t//\t|\t// manually after the class was created.\n\t\t\t//\t|\tB.prototype.method3 = function(){\n\t\t\t//\t|\t\tconsole.log(\"This is a dynamically-added method.\");\n\t\t\t//\t|\t\tthis.inherited(\"method3\", arguments);\n\t\t\t//\t|\t};\n\t\t\t// example:\n\t\t\t//\t|\tvar B = declare(A, {\n\t\t\t//\t|\t\tmethod: function(a, b){\n\t\t\t//\t|\t\t\tvar super = this.inherited(arguments, true);\n\t\t\t//\t|\t\t\t// ...\n\t\t\t//\t|\t\t\tif(!super){\n\t\t\t//\t|\t\t\t\tconsole.log(\"there is no super method\");\n\t\t\t//\t|\t\t\t\treturn 0;\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t\treturn super.apply(this, arguments);\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t|\t\"use strict\";\n\t\t\t//\t|\t// class is defined in strict-mode code,\n\t\t\t//\t|\t// so caller must be passed before arguments.\n\t\t\t//\t|\tvar B = declare(A, {\n\t\t\t//\t|\t\t// using a named function expression with \"fn\" as the name.\n\t\t\t//\t|\t\tmethod: function fn(a, b) {\n\t\t\t//\t|\t\t\tthis.inherited(fn, arguments);\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t});\n\t\t\treturn\t{};\t// Object\n\t\t},\n\n\t\tgetInherited: function(name, caller, args){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a super method.\n\t\t\t// name: String?\n\t\t\t//\t\tThe optional method name. Should be the same as the caller's\n\t\t\t//\t\tname. Usually \"name\" is specified in complex dynamic cases, when\n\t\t\t//\t\tthe calling method was dynamically added, undecorated by\n\t\t\t//\t\tdeclare(), and it cannot be determined.\n\t\t\t// caller: Function?\n\t\t\t//\t\tThe caller function. This is required when running in\n\t\t\t//\t\tstrict-mode code. A reference to the caller function\n\t\t\t//\t\tcan be obtained by using a named function expression\n\t\t\t//\t\t(e.g. function fn(a,b) {...}).\n\t\t\t// args: Arguments\n\t\t\t//\t\tThe caller supply this argument, which should be the original\n\t\t\t//\t\t\"arguments\".\n\t\t\t// returns:\n\t\t\t//\t\tReturns a super method (Function) or \"undefined\".\n\t\t\t// description:\n\t\t\t//\t\tThis method is a convenience method for \"this.inherited()\".\n\t\t\t//\t\tIt uses the same algorithm but instead of executing a super\n\t\t\t//\t\tmethod, it returns it, or \"undefined\" if not found.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\tvar B = declare(A, {\n\t\t\t//\t|\t\tmethod: function(a, b){\n\t\t\t//\t|\t\t\tvar super = this.getInherited(arguments);\n\t\t\t//\t|\t\t\t// ...\n\t\t\t//\t|\t\t\tif(!super){\n\t\t\t//\t|\t\t\t\tconsole.log(\"there is no super method\");\n\t\t\t//\t|\t\t\t\treturn 0;\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t\treturn super.apply(this, arguments);\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t});\n\t\t\t// example:\n\t\t\t//\t|\t\"use strict;\" // first line of function or file\n\t\t\t//\t|\t//...\n\t\t\t//\t|\tvar B = declare(A, {\n\t\t\t//\t|\t\t// Using a named function expression with \"fn\" as the name,\n\t\t\t//\t|\t\t// since we're in strict mode.\n\t\t\t//\t|\t\tmethod: function fn(a, b){\n\t\t\t//\t|\t\t\tvar super = this.getInherited(fn, arguments);\n\t\t\t//\t|\t\t\tif(super){\n\t\t\t//\t|\t\t\t\treturn super.apply(this, arguments);\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t});\n\t\t\treturn\t{};\t// Object\n\t\t},\n\n\t\tisInstanceOf: function(cls){\n\t\t\t// summary:\n\t\t\t//\t\tChecks the inheritance chain to see if it is inherited from this\n\t\t\t//\t\tclass.\n\t\t\t// cls: Function\n\t\t\t//\t\tClass constructor.\n\t\t\t// returns:\n\t\t\t//\t\t\"true\", if this object is inherited from this class, \"false\"\n\t\t\t//\t\totherwise.\n\t\t\t// description:\n\t\t\t//\t\tThis method is used with instances of classes produced with\n\t\t\t//\t\tdeclare() to determine of they support a certain interface or\n\t\t\t//\t\tnot. It models \"instanceof\" operator.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\tvar A = declare(null, {\n\t\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t\t//\t|\t\t// ...\n\t\t\t//\t|\t});\n\t\t\t//\t|\tvar B = declare(null, {\n\t\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t\t//\t|\t\t// ...\n\t\t\t//\t|\t});\n\t\t\t//\t|\tvar C = declare([A, B], {\n\t\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t\t//\t|\t\t// ...\n\t\t\t//\t|\t});\n\t\t\t//\t|\tvar D = declare(A, {\n\t\t\t//\t|\t\t// constructor, properties, and methods go here\n\t\t\t//\t|\t\t// ...\n\t\t\t//\t|\t});\n\t\t\t//\t|\n\t\t\t//\t|\tvar a = new A(), b = new B(), c = new C(), d = new D();\n\t\t\t//\t|\n\t\t\t//\t|\tconsole.log(a.isInstanceOf(A)); // true\n\t\t\t//\t|\tconsole.log(b.isInstanceOf(A)); // false\n\t\t\t//\t|\tconsole.log(c.isInstanceOf(A)); // true\n\t\t\t//\t|\tconsole.log(d.isInstanceOf(A)); // true\n\t\t\t//\t|\n\t\t\t//\t|\tconsole.log(a.isInstanceOf(B)); // false\n\t\t\t//\t|\tconsole.log(b.isInstanceOf(B)); // true\n\t\t\t//\t|\tconsole.log(c.isInstanceOf(B)); // true\n\t\t\t//\t|\tconsole.log(d.isInstanceOf(B)); // false\n\t\t\t//\t|\n\t\t\t//\t|\tconsole.log(a.isInstanceOf(C)); // false\n\t\t\t//\t|\tconsole.log(b.isInstanceOf(C)); // false\n\t\t\t//\t|\tconsole.log(c.isInstanceOf(C)); // true\n\t\t\t//\t|\tconsole.log(d.isInstanceOf(C)); // false\n\t\t\t//\t|\n\t\t\t//\t|\tconsole.log(a.isInstanceOf(D)); // false\n\t\t\t//\t|\tconsole.log(b.isInstanceOf(D)); // false\n\t\t\t//\t|\tconsole.log(c.isInstanceOf(D)); // false\n\t\t\t//\t|\tconsole.log(d.isInstanceOf(D)); // true\n\t\t\treturn\t{};\t// Object\n\t\t},\n\n\t\textend: function(source){\n\t\t\t// summary:\n\t\t\t//\t\tAdds all properties and methods of source to constructor's\n\t\t\t//\t\tprototype, making them available to all instances created with\n\t\t\t//\t\tconstructor. This method is specific to constructors created with\n\t\t\t//\t\tdeclare().\n\t\t\t// source: Object\n\t\t\t//\t\tSource object which properties are going to be copied to the\n\t\t\t//\t\tconstructor's prototype.\n\t\t\t// description:\n\t\t\t//\t\tAdds source properties to the constructor's prototype. It can\n\t\t\t//\t\toverride existing properties.\n\t\t\t//\n\t\t\t//\t\tThis method is similar to dojo.extend function, but it is specific\n\t\t\t//\t\tto constructors produced by declare(). It is implemented\n\t\t\t//\t\tusing dojo.safeMixin, and it skips a constructor property,\n\t\t\t//\t\tand properly decorates copied functions.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\tvar A = declare(null, {\n\t\t\t//\t|\t\tm1: function(){},\n\t\t\t//\t|\t\ts1: \"Popokatepetl\"\n\t\t\t//\t|\t});\n\t\t\t//\t|\tA.extend({\n\t\t\t//\t|\t\tm1: function(){},\n\t\t\t//\t|\t\tm2: function(){},\n\t\t\t//\t|\t\tf1: true,\n\t\t\t//\t|\t\td1: 42\n\t\t\t//\t|\t});\n\t\t},\n\n\t\tcreateSubclass: function(mixins, props){\n\t\t\t// summary:\n\t\t\t//\t\tCreate a subclass of the declared class from a list of base classes.\n\t\t\t// mixins: Function[]\n\t\t\t//\t\tSpecifies a list of bases (the left-most one is the most deepest\n\t\t\t//\t\tbase).\n\t\t\t// props: Object?\n\t\t\t//\t\tAn optional object whose properties are copied to the created prototype.\n\t\t\t// returns: dojo/_base/declare.__DeclareCreatedObject\n\t\t\t//\t\tNew constructor function.\n\t\t\t// description:\n\t\t\t//\t\tCreate a constructor using a compact notation for inheritance and\n\t\t\t//\t\tprototype extension.\n\t\t\t//\n\t\t\t//\t\tMixin ancestors provide a type of multiple inheritance.\n\t\t\t//\t\tPrototypes of mixin ancestors are copied to the new class:\n\t\t\t//\t\tchanges to mixin prototypes will not affect classes to which\n\t\t\t//\t\tthey have been mixed in.\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t|\tvar A = declare(null, {\n\t\t\t//\t|\t\tm1: function(){},\n\t\t\t//\t|\t\ts1: \"bar\"\n\t\t\t//\t|\t});\n\t\t\t//\t|\tvar B = declare(null, {\n\t\t\t//\t|\t\tm2: function(){},\n\t\t\t//\t|\t\ts2: \"foo\"\n\t\t\t//\t|\t});\n\t\t\t//\t|\tvar C = declare(null, {\n\t\t\t//\t|\t});\n\t\t\t//\t|\tvar D1 = A.createSubclass([B, C], {\n\t\t\t//\t|\t\tm1: function(){},\n\t\t\t//\t|\t\td1: 42\n\t\t\t//\t|\t});\n\t\t\t//\t|\tvar d1 = new D1();\n\t\t\t//\t|\n\t\t\t//\t|\t// this is equivalent to:\n\t\t\t//\t|\tvar D2 = declare([A, B, C], {\n\t\t\t//\t|\t\tm1: function(){},\n\t\t\t//\t|\t\td1: 42\n\t\t\t//\t|\t});\n\t\t\t//\t|\tvar d2 = new D2();\n\t\t}\n\t};\n\t=====*/\n\n\t// For back-compat, remove for 2.0\n\tdojo.safeMixin = declare.safeMixin = safeMixin;\n\tdojo.declare = declare;\n\n\treturn declare;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/declare.js?");

/***/ }),

/***/ "./node_modules/dojo/_base/kernel.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/_base/kernel.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../global */ \"./node_modules/dojo/global.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! ./config */ \"./node_modules/dojo/_base/config.js\"), __webpack_require__.dj.c(module.i), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, has, config, require, module){\n\t// module:\n\t//\t\tdojo/_base/kernel\n\n\t// This module is the foundational module of the dojo boot sequence; it defines the dojo object.\n\n\tvar\n\t\t// loop variables for this module\n\t\ti, p,\n\n\t\t// create dojo, dijit, and dojox\n\t\t// FIXME: in 2.0 remove dijit, dojox being created by dojo\n\t\tdijit = {},\n\t\tdojox = {},\n\t\tdojo = {\n\t\t\t// summary:\n\t\t\t//\t\tThis module is the foundational module of the dojo boot sequence; it defines the dojo object.\n\n\t\t\t// notice dojo takes ownership of the value of the config module\n\t\t\tconfig:config,\n\t\t\tglobal:global,\n\t\t\tdijit:dijit,\n\t\t\tdojox:dojox\n\t\t};\n\n\n\t// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide\n\t// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create\n\t// unique names in the global space.\n\t//\n\t// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,\n\t// where global when in fact they are either global under different names or not global at all. In v1.6-, the\n\t// config variable \"scopeMap\" was used to map names as used within a module to global names. This has been\n\t// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,\n\t// only the \"*\" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.\n\t//\n\t// The following computations contort the packageMap for this dojo instance into a scopeMap.\n\tvar scopeMap =\n\t\t\t// a map from a name used in a legacy module to the (global variable name, object addressed by that name)\n\t\t\t// always map dojo, dijit, and dojox\n\t\t\t{\n\t\t\t\tdojo:[\"dojo\", dojo],\n\t\t\t\tdijit:[\"dijit\", dijit],\n\t\t\t\tdojox:[\"dojox\", dojox]\n\t\t\t},\n\n\t\tpackageMap =\n\t\t\t// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config\n\t\t\t(require.map && require.map[module.id.match(/[^\\/]+/)[0]]),\n\n\t\titem;\n\n\n\t// process all mapped top-level names for this instance of dojo\n\tfor(p in packageMap){\n\t\tif(scopeMap[p]){\n\t\t\t// mapped dojo, dijit, or dojox\n\t\t\tscopeMap[p][0] = packageMap[p];\n\t\t}else{\n\t\t\t// some other top-level name\n\t\t\tscopeMap[p] = [packageMap[p], {}];\n\t\t}\n\t}\n\n\t// publish those names to _scopeName and, optionally, the global namespace\n\tfor(p in scopeMap){\n\t\titem = scopeMap[p];\n\t\titem[1]._scopeName = item[0];\n\t\tif(!config.noGlobals){\n\t\t\tglobal[item[0]] = item[1];\n\t\t}\n\t}\n\tdojo.scopeMap = scopeMap;\n\n\t/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/\n\n\t// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated\n\tdojo.baseUrl = dojo.config.baseUrl = require.baseUrl;\n\tdojo.isAsync = !has(\"dojo-loader\") || require.async;\n\tdojo.locale = config.locale;\n\n\tvar rev = \"$Rev:$\".match(/[0-9a-f]{7,}/);\n\tdojo.version = {\n\t\t// summary:\n\t\t//\t\tVersion number of the Dojo Toolkit\n\t\t// description:\n\t\t//\t\tHash about the version, including\n\t\t//\n\t\t//\t\t- major: Integer: Major version. If total version is \"1.2.0beta1\", will be 1\n\t\t//\t\t- minor: Integer: Minor version. If total version is \"1.2.0beta1\", will be 2\n\t\t//\t\t- patch: Integer: Patch version. If total version is \"1.2.0beta1\", will be 0\n\t\t//\t\t- flag: String: Descriptor flag. If total version is \"1.2.0beta1\", will be \"beta1\"\n\t\t//\t\t- revision: Number: The Git rev from which dojo was pulled\n\n\t\tmajor: 1, minor: 16, patch: 0, flag: \"\",\n\t\trevision: rev ? rev[0] : NaN,\n\t\ttoString: function(){\n\t\t\tvar v = dojo.version;\n\t\t\treturn v.major + \".\" + v.minor + \".\" + v.patch + v.flag + \" (\" + v.revision + \")\";\t// String\n\t\t}\n\t};\n\n\t// If has(\"extend-dojo\") is truthy, then as a dojo module is defined it should push it's definitions\n\t// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object\n\t// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code\n\t// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.\n\thas.add(\"extend-dojo\", 1);\n\n\tif(!has(\"csp-restrictions\")){\n\t\t(Function(\"d\", \"d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}\"))(dojo);\n\t}\n\t/*=====\n\tdojo.eval = function(scriptText){\n\t\t// summary:\n\t\t//\t\tA legacy method created for use exclusively by internal Dojo methods. Do not use this method\n\t\t//\t\tdirectly unless you understand its possibly-different implications on the platforms your are targeting.\n\t\t// description:\n\t\t//\t\tMakes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers\n\t\t//\t\tthat support indirect eval.\n\t\t//\n\t\t//\t\tAs usual, IE does not. On IE, the only way to implement global eval is to\n\t\t//\t\tuse execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.\n\t\t//\t\tThis implementation uses the technique of executing eval in the scope of a function that is a single scope\n\t\t//\t\tframe below the global scope; thereby coming close to the global scope. Note carefully that\n\t\t//\n\t\t//\t\tdojo.eval(\"var pi = 3.14;\");\n\t\t//\n\t\t//\t\twill define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want\n\t\t//\t\tto define a global variable using dojo.eval, write something like\n\t\t//\n\t\t//\t\tdojo.eval(\"window.pi = 3.14;\")\n\t\t// scriptText:\n\t\t//\t\tThe text to evaluation.\n\t\t// returns:\n\t\t//\t\tThe result of the evaluation. Often `undefined`\n\t};\n\t=====*/\n\n\n\tif(has(\"host-rhino\")){\n\t\tdojo.exit = function(exitcode){\n\t\t\tquit(exitcode);\n\t\t};\n\t}else{\n\t\tdojo.exit = function(){\n\t\t};\n\t}\n\n\tif(!has(\"host-webworker\")){\n\t\t// console is immutable in FF30+, https://bugs.dojotoolkit.org/ticket/18100\n\t\thas.add(\"dojo-guarantee-console\",\n\t\t\t// ensure that console.log, console.warn, etc. are defined\n\t\t\t1\n\t\t);\n\t}\n\n\tif(has(\"dojo-guarantee-console\")){\n\t\t// IE 9 bug: https://bugs.dojotoolkit.org/ticket/18197\n\t\thas.add(\"console-as-object\", function () {\n\t\t\treturn Function.prototype.bind && console && typeof console.log === \"object\";\n\t\t});\n\n\t\ttypeof console != \"undefined\" || (console = {});  // intentional assignment\n\t\t//\tBe careful to leave 'log' always at the end\n\t\tvar cn = [\n\t\t\t\"assert\", \"count\", \"debug\", \"dir\", \"dirxml\", \"error\", \"group\",\n\t\t\t\"groupEnd\", \"info\", \"profile\", \"profileEnd\", \"time\", \"timeEnd\",\n\t\t\t\"trace\", \"warn\", \"log\"\n\t\t];\n\t\tvar tn;\n\t\ti = 0;\n\t\twhile((tn = cn[i++])){\n\t\t\tif(!console[tn]){\n\t\t\t\t(function(){\n\t\t\t\t\tvar tcn = tn + \"\";\n\t\t\t\t\tconsole[tcn] = ('log' in console) ? function(){\n\t\t\t\t\t\tvar a = Array.prototype.slice.call(arguments);\n\t\t\t\t\t\ta.unshift(tcn + \":\");\n\t\t\t\t\t\tconsole[\"log\"](a.join(\" \"));\n\t\t\t\t\t} : function(){};\n\t\t\t\t\tconsole[tcn]._fake = true;\n\t\t\t\t})();\n\t\t\t}else if(has(\"console-as-object\")){\n\t\t\t\tconsole[tn] = Function.prototype.bind.call(console[tn], console);\n\t\t\t}\n\t\t}\n\t}\n\n\thas.add(\"dojo-debug-messages\",\n\t\t// include dojo.deprecated/dojo.experimental implementations\n\t\t!!config.isDebug\n\t);\n\tdojo.deprecated = dojo.experimental =  function(){};\n\tif(has(\"dojo-debug-messages\")){\n\t\tdojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){\n\t\t\t// summary:\n\t\t\t//\t\tLog a debug message to indicate that a behavior has been\n\t\t\t//\t\tdeprecated.\n\t\t\t// behaviour: String\n\t\t\t//\t\tThe API or behavior being deprecated. Usually in the form\n\t\t\t//\t\tof \"myApp.someFunction()\".\n\t\t\t// extra: String?\n\t\t\t//\t\tText to append to the message. Often provides advice on a\n\t\t\t//\t\tnew function or facility to achieve the same goal during\n\t\t\t//\t\tthe deprecation period.\n\t\t\t// removal: String?\n\t\t\t//\t\tText to indicate when in the future the behavior will be\n\t\t\t//\t\tremoved. Usually a version number.\n\t\t\t// example:\n\t\t\t//\t| dojo.deprecated(\"myApp.getTemp()\", \"use myApp.getLocaleTemp() instead\", \"1.0\");\n\n\t\t\tvar message = \"DEPRECATED: \" + behaviour;\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tif(removal){ message += \" -- will be removed in version: \" + removal; }\n\t\t\tconsole.warn(message);\n\t\t};\n\n\t\tdojo.experimental = function(/* String */ moduleName, /* String? */ extra){\n\t\t\t// summary:\n\t\t\t//\t\tMarks code as experimental.\n\t\t\t// description:\n\t\t\t//\t\tThis can be used to mark a function, file, or module as\n\t\t\t//\t\texperimental.\t Experimental code is not ready to be used, and the\n\t\t\t//\t\tAPIs are subject to change without notice.\tExperimental code may be\n\t\t\t//\t\tcompleted deleted without going through the normal deprecation\n\t\t\t//\t\tprocess.\n\t\t\t// moduleName: String\n\t\t\t//\t\tThe name of a module, or the name of a module file or a specific\n\t\t\t//\t\tfunction\n\t\t\t// extra: String?\n\t\t\t//\t\tsome additional message for the user\n\t\t\t// example:\n\t\t\t//\t| dojo.experimental(\"dojo.data.Result\");\n\t\t\t// example:\n\t\t\t//\t| dojo.experimental(\"dojo.weather.toKelvin()\", \"PENDING approval from NOAA\");\n\n\t\t\tvar message = \"EXPERIMENTAL: \" + moduleName + \" -- APIs subject to change without notice.\";\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tconsole.warn(message);\n\t\t};\n\t}\n\n\thas.add(\"dojo-modulePaths\",\n\t\t// consume dojo.modulePaths processing\n\t\t1\n\t);\n\tif(has(\"dojo-modulePaths\")){\n\t\t// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;\n\t\t// this is the v1.6- behavior.\n\t\tif(config.modulePaths){\n\t\t\tdojo.deprecated(\"dojo.modulePaths\", \"use paths configuration\");\n\t\t\tvar paths = {};\n\t\t\tfor(p in config.modulePaths){\n\t\t\t\tpaths[p.replace(/\\./g, \"/\")] = config.modulePaths[p];\n\t\t\t}\n\t\t\trequire({paths:paths});\n\t\t}\n\t}\n\n\thas.add(\"dojo-moduleUrl\",\n\t\t// include dojo.moduleUrl\n\t\t1\n\t);\n\tif(has(\"dojo-moduleUrl\")){\n\t\tdojo.moduleUrl = function(/*String*/module, /*String?*/url){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a URL relative to a module.\n\t\t\t// example:\n\t\t\t//\t|\tvar pngPath = dojo.moduleUrl(\"acme\",\"images/small.png\");\n\t\t\t//\t|\tconsole.dir(pngPath); // list the object properties\n\t\t\t//\t|\t// create an image and set it's source to pngPath's value:\n\t\t\t//\t|\tvar img = document.createElement(\"img\");\n\t\t\t//\t|\timg.src = pngPath;\n\t\t\t//\t|\t// add our image to the document\n\t\t\t//\t|\tdojo.body().appendChild(img);\n\t\t\t// example:\n\t\t\t//\t\tyou may de-reference as far as you like down the package\n\t\t\t//\t\thierarchy.  This is sometimes handy to avoid lengthy relative\n\t\t\t//\t\turls or for building portable sub-packages. In this example,\n\t\t\t//\t\tthe `acme.widget` and `acme.util` directories may be located\n\t\t\t//\t\tunder different roots (see `dojo.registerModulePath`) but the\n\t\t\t//\t\tthe modules which reference them can be unaware of their\n\t\t\t//\t\trelative locations on the filesystem:\n\t\t\t//\t|\t// somewhere in a configuration block\n\t\t\t//\t|\tdojo.registerModulePath(\"acme.widget\", \"../../acme/widget\");\n\t\t\t//\t|\tdojo.registerModulePath(\"acme.util\", \"../../util\");\n\t\t\t//\t|\n\t\t\t//\t|\t// ...\n\t\t\t//\t|\n\t\t\t//\t|\t// code in a module using acme resources\n\t\t\t//\t|\tvar tmpltPath = dojo.moduleUrl(\"acme.widget\",\"templates/template.html\");\n\t\t\t//\t|\tvar dataPath = dojo.moduleUrl(\"acme.util\",\"resources/data.json\");\n\n\t\t\tdojo.deprecated(\"dojo.moduleUrl()\", \"use require.toUrl\", \"2.0\");\n\n\t\t\t// require.toUrl requires a filetype; therefore, just append the suffix \"/*.*\" to guarantee a filetype, then\n\t\t\t// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be\n\t\t\t// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).\n\t\t\t// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.\n\t\t\tvar result = null;\n\t\t\tif(module){\n\t\t\t\tresult = require.toUrl(module.replace(/\\./g, \"/\") + (url ? (\"/\" + url) : \"\") + \"/*.*\").replace(/\\/\\*\\.\\*/, \"\") + (url ? \"\" : \"/\");\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}\n\n\tdojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling\n\n\treturn dojo;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/kernel.js?");

/***/ }),

/***/ "./node_modules/dojo/_base/lang.js":
/*!*****************************************!*\
  !*** ./node_modules/dojo/_base/lang.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! ../sniff */ \"./node_modules/dojo/sniff.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has){\n\t// module:\n\t//\t\tdojo/_base/lang\n\n\thas.add(\"bug-for-in-skips-shadowed\", function(){\n\t\t// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)\n\t\tfor(var i in {toString: 1}){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t});\n\n\t// Helper methods\n\tvar _extraNames =\n\t\t\thas(\"bug-for-in-skips-shadowed\") ?\n\t\t\t\t\"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor\".split(\".\") : [],\n\n\t\t_extraLen = _extraNames.length,\n\n\t\tgetProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){\n\t\t\tif(!context){\n\t\t\t\tif(parts[0] && dojo.scopeMap[parts[0]]) {\n\t\t\t\t\t// Voodoo code from the old days where \"dojo\" or \"dijit\" maps to some special object\n\t\t\t\t\t// rather than just window.dojo\n\t\t\t\t\tcontext = dojo.scopeMap[parts.shift()][1];\n\t\t\t\t}else{\n\t\t\t\t\tcontext = dojo.global;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry{\n\t\t\t\tfor(var i = 0; i < parts.length; i++){\n\t\t\t\t\tvar p = parts[i];\n\t\t\t\t\tif(!(p in context)){\n\t\t\t\t\t\tif(create){\n\t\t\t\t\t\t\tcontext[p] = {};\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn;\t\t// return undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontext = context[p];\n\t\t\t\t}\n\t\t\t\treturn context; // mixed\n\t\t\t}catch(e){\n\t\t\t\t// \"p in context\" throws an exception when context is a number, boolean, etc. rather than an object,\n\t\t\t\t// so in that corner case just return undefined (by having no return statement)\n\t\t\t}\n\t\t},\n\n\t\topts = Object.prototype.toString,\n\n\t\tefficient = function(obj, offset, startWith){\n\t\t\treturn (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));\n\t\t},\n\n\t\t_pattern = /\\{([^\\}]+)\\}/g;\n\n\t// Module export\n\tvar lang = {\n\t\t// summary:\n\t\t//\t\tThis module defines Javascript language extensions.\n\n\t\t// _extraNames: String[]\n\t\t//\t\tLists property names that must be explicitly processed during for-in iteration\n\t\t//\t\tin environments that have has(\"bug-for-in-skips-shadowed\") true.\n\t\t_extraNames:_extraNames,\n\n\t\t_mixin: function(dest, source, copyFunc){\n\t\t\t// summary:\n\t\t\t//\t\tCopies/adds all properties of source to dest; returns dest.\n\t\t\t// dest: Object\n\t\t\t//\t\tThe object to which to copy/add all properties contained in source.\n\t\t\t// source: Object\n\t\t\t//\t\tThe object from which to draw all properties to copy into dest.\n\t\t\t// copyFunc: Function?\n\t\t\t//\t\tThe process used to copy/add a property in source; defaults to the Javascript assignment operator.\n\t\t\t// returns:\n\t\t\t//\t\tdest, as modified\n\t\t\t// description:\n\t\t\t//\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\t\t//\t\tfound in Object.prototype, are copied/added to dest. Copying/adding each particular property is\n\t\t\t//\t\tdelegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.\n\t\t\t//\t\tNotice that by default, _mixin executes a so-called \"shallow copy\" and aggregate types are copied/added by reference.\n\t\t\tvar name, s, i, empty = {};\n\t\t\tfor(name in source){\n\t\t\t\t// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\n\t\t\t\t// inherited from Object.prototype.\t For example, if dest has a custom toString() method,\n\t\t\t\t// don't overwrite it with the toString() method that source inherited from Object.prototype\n\t\t\t\ts = source[name];\n\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\t\tif(source){\n\t\t\t\t\tfor(i = 0; i < _extraLen; ++i){\n\t\t\t\t\t\tname = _extraNames[i];\n\t\t\t\t\t\ts = source[name];\n\t\t\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest; // Object\n\t\t},\n\n\t\tmixin: function(dest, sources){\n\t\t\t// summary:\n\t\t\t//\t\tCopies/adds all properties of one or more sources to dest; returns dest.\n\t\t\t// dest: Object\n\t\t\t//\t\tThe object to which to copy/add all properties contained in source. If dest is falsy, then\n\t\t\t//\t\ta new object is manufactured before copying/adding properties begins.\n\t\t\t// sources: Object...\n\t\t\t//\t\tOne of more objects from which to draw all properties to copy into dest. sources are processed\n\t\t\t//\t\tleft-to-right and if more than one of these objects contain the same property name, the right-most\n\t\t\t//\t\tvalue \"wins\".\n\t\t\t// returns: Object\n\t\t\t//\t\tdest, as modified\n\t\t\t// description:\n\t\t\t//\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\t\t//\t\tfound in Object.prototype, are copied/added from sources to dest. sources are processed left to right.\n\t\t\t//\t\tThe Javascript assignment operator is used to copy/add each property; therefore, by default, mixin\n\t\t\t//\t\texecutes a so-called \"shallow copy\" and aggregate types are copied/added by reference.\n\t\t\t// example:\n\t\t\t//\t\tmake a shallow copy of an object\n\t\t\t//\t|\tvar copy = lang.mixin({}, source);\n\t\t\t// example:\n\t\t\t//\t\tmany class constructors often take an object which specifies\n\t\t\t//\t\tvalues to be configured on the object. In this case, it is\n\t\t\t//\t\toften simplest to call `lang.mixin` on the `this` object:\n\t\t\t//\t|\tdeclare(\"acme.Base\", null, {\n\t\t\t//\t|\t\tconstructor: function(properties){\n\t\t\t//\t|\t\t\t// property configuration:\n\t\t\t//\t|\t\t\tlang.mixin(this, properties);\n\t\t\t//\t|\n\t\t\t//\t|\t\t\tconsole.log(this.quip);\n\t\t\t//\t|\t\t\t//\t...\n\t\t\t//\t|\t\t},\n\t\t\t//\t|\t\tquip: \"I wasn't born yesterday, you know - I've seen movies.\",\n\t\t\t//\t|\t\t// ...\n\t\t\t//\t|\t});\n\t\t\t//\t|\n\t\t\t//\t|\t// create an instance of the class and configure it\n\t\t\t//\t|\tvar b = new acme.Base({quip: \"That's what it does!\" });\n\t\t\t// example:\n\t\t\t//\t\tcopy in properties from multiple objects\n\t\t\t//\t|\tvar flattened = lang.mixin(\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tname: \"Frylock\",\n\t\t\t//\t|\t\t\tbraces: true\n\t\t\t//\t|\t\t},\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tname: \"Carl Brutanananadilewski\"\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t);\n\t\t\t//\t|\n\t\t\t//\t|\t// will print \"Carl Brutanananadilewski\"\n\t\t\t//\t|\tconsole.log(flattened.name);\n\t\t\t//\t|\t// will print \"true\"\n\t\t\t//\t|\tconsole.log(flattened.braces);\n\n\t\t\tif(!dest){ dest = {}; }\n\t\t\tfor(var i = 1, l = arguments.length; i < l; i++){\n\t\t\t\tlang._mixin(dest, arguments[i]);\n\t\t\t}\n\t\t\treturn dest; // Object\n\t\t},\n\n\t\tsetObject: function(name, value, context){\n\t\t\t// summary:\n\t\t\t//\t\tSet a property from a dot-separated string, such as \"A.B.C\"\n\t\t\t// description:\n\t\t\t//\t\tUseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain, or when you have an object reference in string format.\n\t\t\t//\t\tObjects are created as needed along `path`. Returns the passed\n\t\t\t//\t\tvalue if setting is successful or `undefined` if not.\n\t\t\t// name: String\n\t\t\t//\t\tPath to a property, in the form \"A.B.C\".\n\t\t\t// value: anything\n\t\t\t//\t\tvalue or object to place at location given by name\n\t\t\t// context: Object?\n\t\t\t//\t\tOptional. Object to use as root of path. Defaults to\n\t\t\t//\t\t`dojo.global`.\n\t\t\t// example:\n\t\t\t//\t\tset the value of `foo.bar.baz`, regardless of whether\n\t\t\t//\t\tintermediate objects already exist:\n\t\t\t//\t| lang.setObject(\"foo.bar.baz\", value);\n\t\t\t// example:\n\t\t\t//\t\twithout `lang.setObject`, we often see code like this:\n\t\t\t//\t| // ensure that intermediate objects are available\n\t\t\t//\t| if(!obj[\"parent\"]){ obj.parent = {}; }\n\t\t\t//\t| if(!obj.parent[\"child\"]){ obj.parent.child = {}; }\n\t\t\t//\t| // now we can safely set the property\n\t\t\t//\t| obj.parent.child.prop = \"some value\";\n\t\t\t//\t\twhereas with `lang.setObject`, we can shorten that to:\n\t\t\t//\t| lang.setObject(\"parent.child.prop\", \"some value\", obj);\n\n\t\t\tvar parts = name.split(\".\"), p = parts.pop(), obj = getProp(parts, true, context);\n\t\t\treturn obj && p ? (obj[p] = value) : undefined; // Object\n\t\t},\n\n\t\tgetObject: function(name, create, context){\n\t\t\t// summary:\n\t\t\t//\t\tGet a property from a dot-separated string, such as \"A.B.C\"\n\t\t\t// description:\n\t\t\t//\t\tUseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain, or when you have an object reference in string format.\n\t\t\t// name: String\n\t\t\t//\t\tPath to an property, in the form \"A.B.C\".\n\t\t\t// create: Boolean?\n\t\t\t//\t\tOptional. Defaults to `false`. If `true`, Objects will be\n\t\t\t//\t\tcreated at any point along the 'path' that is undefined.\n\t\t\t// context: Object?\n\t\t\t//\t\tOptional. Object to use as root of path. Defaults to\n\t\t\t//\t\t'dojo.global'. Null may be passed.\n\t\t\treturn !name ? context : getProp(name.split(\".\"), create, context); // Object\n\t\t},\n\n\t\texists: function(name, obj){\n\t\t\t// summary:\n\t\t\t//\t\tdetermine if an object supports a given method\n\t\t\t// description:\n\t\t\t//\t\tuseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain. Useful for object and method detection.\n\t\t\t// name: String\n\t\t\t//\t\tPath to an object, in the form \"A.B.C\".\n\t\t\t// obj: Object?\n\t\t\t//\t\tObject to use as root of path. Defaults to\n\t\t\t//\t\t'dojo.global'. Null may be passed.\n\t\t\t// example:\n\t\t\t//\t| // define an object\n\t\t\t//\t| var foo = {\n\t\t\t//\t|\t\tbar: { }\n\t\t\t//\t| };\n\t\t\t//\t|\n\t\t\t//\t| // search the global scope\n\t\t\t//\t| lang.exists(\"foo.bar\"); // true\n\t\t\t//\t| lang.exists(\"foo.bar.baz\"); // false\n\t\t\t//\t|\n\t\t\t//\t| // search from a particular scope\n\t\t\t//\t| lang.exists(\"bar\", foo); // true\n\t\t\t//\t| lang.exists(\"bar.baz\", foo); // false\n\t\t\treturn lang.getObject(name, false, obj) !== undefined; // Boolean\n\t\t},\n\n\t\t// Crockford (ish) functions\n\n\t\tisString: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is a String\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn (typeof it == \"string\" || it instanceof String); // Boolean\n\t\t},\n\n\t\tisArray: Array.isArray || function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is an Array.\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn opts.call(it) == \"[object Array]\"; // Boolean\n\t\t},\n\n\t\tisFunction: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is a Function\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn opts.call(it) === \"[object Function]\";\n\t\t},\n\n\t\tisObject: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturns true if it is a JavaScript object (or an Array, a Function\n\t\t\t//\t\tor null)\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn it !== undefined &&\n\t\t\t\t(it === null || typeof it == \"object\" || lang.isArray(it) || lang.isFunction(it)); // Boolean\n\t\t},\n\n\t\tisArrayLike: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tsimilar to isArray() but more permissive\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\t// returns:\n\t\t\t//\t\tIf it walks like a duck and quacks like a duck, return `true`\n\t\t\t// description:\n\t\t\t//\t\tDoesn't strongly test for \"arrayness\".  Instead, settles for \"isn't\n\t\t\t//\t\ta string or number and has a length property\". Arguments objects\n\t\t\t//\t\tand DOM collections will return true when passed to\n\t\t\t//\t\tisArrayLike(), but will return false when passed to\n\t\t\t//\t\tisArray().\n\t\t\treturn !!it && // Boolean\n\t\t\t\t// keep out built-in constructors (Number, String, ...) which have length\n\t\t\t\t// properties\n\t\t\t\t!lang.isString(it) && !lang.isFunction(it) &&\n\t\t\t\t!(it.tagName && it.tagName.toLowerCase() == 'form') &&\n\t\t\t\t(lang.isArray(it) || isFinite(it.length));\n\t\t},\n\n\t\tisAlien: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturns true if it is a built-in function or some other kind of\n\t\t\t//\t\toddball that *should* report as a function but doesn't\n\t\t\treturn it && !lang.isFunction(it) && /\\{\\s*\\[native code\\]\\s*\\}/.test(String(it)); // Boolean\n\t\t},\n\n\t\textend: function(ctor, props){\n\t\t\t// summary:\n\t\t\t//\t\tAdds all properties and methods of props to constructor's\n\t\t\t//\t\tprototype, making them available to all instances created with\n\t\t\t//\t\tconstructor.\n\t\t\t// ctor: Object\n\t\t\t//\t\tTarget constructor to extend.\n\t\t\t// props: Object\n\t\t\t//\t\tOne or more objects to mix into ctor.prototype\n\t\t\tfor(var i=1, l=arguments.length; i<l; i++){\n\t\t\t\tlang._mixin(ctor.prototype, arguments[i]);\n\t\t\t}\n\t\t\treturn ctor; // Object\n\t\t},\n\n\t\t_hitchArgs: function(scope, method){\n\t\t\tvar pre = lang._toArray(arguments, 2);\n\t\t\tvar named = lang.isString(method);\n\t\t\treturn function(){\n\t\t\t\t// arrayify arguments\n\t\t\t\tvar args = lang._toArray(arguments);\n\t\t\t\t// locate our method\n\t\t\t\tvar f = named ? (scope||dojo.global)[method] : method;\n\t\t\t\t// invoke with collected args\n\t\t\t\treturn f && f.apply(scope || this, pre.concat(args)); // mixed\n\t\t\t}; // Function\n\t\t},\n\n\t\thitch: function(scope, method){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a function that will only ever execute in the given scope.\n\t\t\t//\t\tThis allows for easy use of object member functions\n\t\t\t//\t\tin callbacks and other places in which the \"this\" keyword may\n\t\t\t//\t\totherwise not reference the expected scope.\n\t\t\t//\t\tAny number of default positional arguments may be passed as parameters\n\t\t\t//\t\tbeyond \"method\".\n\t\t\t//\t\tEach of these values will be used to \"placehold\" (similar to curry)\n\t\t\t//\t\tfor the hitched function.\n\t\t\t// scope: Object\n\t\t\t//\t\tThe scope to use when method executes. If method is a string,\n\t\t\t//\t\tscope is also the object containing method.\n\t\t\t// method: Function|String...\n\t\t\t//\t\tA function to be hitched to scope, or the name of the method in\n\t\t\t//\t\tscope to be hitched.\n\t\t\t// example:\n\t\t\t//\t|\tlang.hitch(foo, \"bar\")();\n\t\t\t//\t\truns foo.bar() in the scope of foo\n\t\t\t// example:\n\t\t\t//\t|\tlang.hitch(foo, myFunction);\n\t\t\t//\t\treturns a function that runs myFunction in the scope of foo\n\t\t\t// example:\n\t\t\t//\t\tExpansion on the default positional arguments passed along from\n\t\t\t//\t\thitch. Passed args are mixed first, additional args after.\n\t\t\t//\t|\tvar foo = { bar: function(a, b, c){ console.log(a, b, c); } };\n\t\t\t//\t|\tvar fn = lang.hitch(foo, \"bar\", 1, 2);\n\t\t\t//\t|\tfn(3); // logs \"1, 2, 3\"\n\t\t\t// example:\n\t\t\t//\t|\tvar foo = { bar: 2 };\n\t\t\t//\t|\tlang.hitch(foo, function(){ this.bar = 10; })();\n\t\t\t//\t\texecute an anonymous function in scope of foo\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn lang._hitchArgs.apply(dojo, arguments); // Function\n\t\t\t}\n\t\t\tif(!method){\n\t\t\t\tmethod = scope;\n\t\t\t\tscope = null;\n\t\t\t}\n\t\t\tif(lang.isString(method)){\n\t\t\t\tscope = scope || dojo.global;\n\t\t\t\tif(!scope[method]){ throw(['lang.hitch: scope[\"', method, '\"] is null (scope=\"', scope, '\")'].join('')); }\n\t\t\t\treturn function(){ return scope[method].apply(scope, arguments || []); }; // Function\n\t\t\t}\n\t\t\treturn !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function\n\t\t},\n\n\t\tdelegate: (function(){\n\t\t\t// boodman/crockford delegation w/ cornford optimization\n\t\t\tfunction TMP(){}\n\t\t\treturn function(obj, props){\n\t\t\t\tTMP.prototype = obj;\n\t\t\t\tvar tmp = new TMP();\n\t\t\t\tTMP.prototype = null;\n\t\t\t\tif(props){\n\t\t\t\t\tlang._mixin(tmp, props);\n\t\t\t\t}\n\t\t\t\treturn tmp; // Object\n\t\t\t};\n\t\t})(),\n\t\t/*=====\n\t\tdelegate: function(obj, props){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new object which \"looks\" to obj for properties which it\n\t\t\t//\t\tdoes not have a value for. Optionally takes a bag of properties to\n\t\t\t//\t\tseed the returned object with initially.\n\t\t\t// description:\n\t\t\t//\t\tThis is a small implementation of the Boodman/Crockford delegation\n\t\t\t//\t\tpattern in JavaScript. An intermediate object constructor mediates\n\t\t\t//\t\tthe prototype chain for the returned object, using it to delegate\n\t\t\t//\t\tdown to obj for property lookup when object-local lookup fails.\n\t\t\t//\t\tThis can be thought of similarly to ES4's \"wrap\", save that it does\n\t\t\t//\t\tnot act on types but rather on pure objects.\n\t\t\t// obj: Object\n\t\t\t//\t\tThe object to delegate to for properties not found directly on the\n\t\t\t//\t\treturn object or in props.\n\t\t\t// props: Object...\n\t\t\t//\t\tan object containing properties to assign to the returned object\n\t\t\t// returns:\n\t\t\t//\t\tan Object of anonymous type\n\t\t\t// example:\n\t\t\t//\t|\tvar foo = { bar: \"baz\" };\n\t\t\t//\t|\tvar thinger = lang.delegate(foo, { thud: \"xyzzy\"});\n\t\t\t//\t|\tthinger.bar == \"baz\"; // delegated to foo\n\t\t\t//\t|\tfoo.thud == undefined; // by definition\n\t\t\t//\t|\tthinger.thud == \"xyzzy\"; // mixed in from props\n\t\t\t//\t|\tfoo.bar = \"thonk\";\n\t\t\t//\t|\tthinger.bar == \"thonk\"; // still delegated to foo's bar\n\t\t},\n\t\t=====*/\n\n\t\t_toArray: has(\"ie\") ?\n\t\t\t(function(){\n\t\t\t\tfunction slow(obj, offset, startWith){\n\t\t\t\t\tvar arr = startWith||[];\n\t\t\t\t\tfor(var x = offset || 0; x < obj.length; x++){\n\t\t\t\t\t\tarr.push(obj[x]);\n\t\t\t\t\t}\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\t\t\t\treturn function(obj){\n\t\t\t\t\treturn ((obj.item) ? slow : efficient).apply(this, arguments);\n\t\t\t\t};\n\t\t\t})() : efficient,\n\t\t/*=====\n\t\t _toArray: function(obj, offset, startWith){\n\t\t\t // summary:\n\t\t\t //\t\tConverts an array-like object (i.e. arguments, DOMCollection) to an\n\t\t\t //\t\tarray. Returns a new Array with the elements of obj.\n\t\t\t // obj: Object\n\t\t\t //\t\tthe object to \"arrayify\". We expect the object to have, at a\n\t\t\t //\t\tminimum, a length property which corresponds to integer-indexed\n\t\t\t //\t\tproperties.\n\t\t\t // offset: Number?\n\t\t\t //\t\tthe location in obj to start iterating from. Defaults to 0.\n\t\t\t //\t\tOptional.\n\t\t\t // startWith: Array?\n\t\t\t //\t\tAn array to pack with the properties of obj. If provided,\n\t\t\t //\t\tproperties in obj are appended at the end of startWith and\n\t\t\t //\t\tstartWith is the returned array.\n\t\t },\n\t\t =====*/\n\n\t\tpartial: function(/*Function|String*/ method /*, ...*/){\n\t\t\t// summary:\n\t\t\t//\t\tsimilar to hitch() except that the scope object is left to be\n\t\t\t//\t\twhatever the execution context eventually becomes.\n\t\t\t// description:\n\t\t\t//\t\tCalling lang.partial is the functional equivalent of calling:\n\t\t\t//\t\t|\tlang.hitch(null, funcName, ...);\n\t\t\t// method:\n\t\t\t//\t\tThe function to \"wrap\"\n\t\t\tvar arr = [ null ];\n\t\t\treturn lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function\n\t\t},\n\n\t\tclone: function(/*anything*/ src){\n\t\t\t// summary:\n\t\t\t//\t\tClones objects (including DOM nodes) and all children.\n\t\t\t//\t\tWarning: do not clone cyclic structures.\n\t\t\t// src:\n\t\t\t//\t\tThe object to clone\n\t\t\tif(!src || typeof src != \"object\" || lang.isFunction(src)){\n\t\t\t\t// null, undefined, any non-object, or function\n\t\t\t\treturn src;\t// anything\n\t\t\t}\n\t\t\tif(src.nodeType && \"cloneNode\" in src){\n\t\t\t\t// DOM Node\n\t\t\t\treturn src.cloneNode(true); // Node\n\t\t\t}\n\t\t\tif(src instanceof Date){\n\t\t\t\t// Date\n\t\t\t\treturn new Date(src.getTime());\t// Date\n\t\t\t}\n\t\t\tif(src instanceof RegExp){\n\t\t\t\t// RegExp\n\t\t\t\treturn new RegExp(src);   // RegExp\n\t\t\t}\n\t\t\tvar r, i, l;\n\t\t\tif(lang.isArray(src)){\n\t\t\t\t// array\n\t\t\t\tr = [];\n\t\t\t\tfor(i = 0, l = src.length; i < l; ++i){\n\t\t\t\t\tif(i in src){\n\t\t\t\t\t\tr[i] = lang.clone(src[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// we don't clone functions for performance reasons\n\t\t\t\t//\t\t}else if(d.isFunction(src)){\n\t\t\t\t//\t\t\t// function\n\t\t\t\t//\t\t\tr = function(){ return src.apply(this, arguments); };\n\t\t\t}else{\n\t\t\t\t// generic objects\n\t\t\t\tr = src.constructor ? new src.constructor() : {};\n\t\t\t}\n\t\t\treturn lang._mixin(r, src, lang.clone);\n\t\t},\n\n\n\t\ttrim: String.prototype.trim ?\n\t\t\tfunction(str){ return str.trim(); } :\n\t\t\tfunction(str){ return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); },\n\t\t/*=====\n\t\t trim: function(str){\n\t\t\t // summary:\n\t\t\t //\t\tTrims whitespace from both sides of the string\n\t\t\t // str: String\n\t\t\t //\t\tString to be trimmed\n\t\t\t // returns: String\n\t\t\t //\t\tReturns the trimmed string\n\t\t\t // description:\n\t\t\t //\t\tThis version of trim() was selected for inclusion into the base due\n\t\t\t //\t\tto its compact size and relatively good performance\n\t\t\t //\t\t(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)\n\t\t\t //\t\tUses String.prototype.trim instead, if available.\n\t\t\t //\t\tThe fastest but longest version of this function is located at\n\t\t\t //\t\tlang.string.trim()\n\t\t },\n\t\t =====*/\n\n\t\treplace: function(tmpl, map, pattern){\n\t\t\t// summary:\n\t\t\t//\t\tPerforms parameterized substitutions on a string. Throws an\n\t\t\t//\t\texception if any parameter is unmatched.\n\t\t\t// tmpl: String\n\t\t\t//\t\tString to be used as a template.\n\t\t\t// map: Object|Function\n\t\t\t//\t\tIf an object, it is used as a dictionary to look up substitutions.\n\t\t\t//\t\tIf a function, it is called for every substitution with following parameters:\n\t\t\t//\t\ta whole match, a name, an offset, and the whole template\n\t\t\t//\t\tstring (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace\n\t\t\t//\t\tfor more details).\n\t\t\t// pattern: RegEx?\n\t\t\t//\t\tOptional regular expression objects that overrides the default pattern.\n\t\t\t//\t\tMust be global and match one item. The default is: /\\{([^\\}]+)\\}/g,\n\t\t\t//\t\twhich matches patterns like that: \"{xxx}\", where \"xxx\" is any sequence\n\t\t\t//\t\tof characters, which doesn't include \"}\".\n\t\t\t// returns: String\n\t\t\t//\t\tReturns the substituted string.\n\t\t\t// example:\n\t\t\t//\t|\t// uses a dictionary for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, {name.first} {name.last} AKA {nick}!\",\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tnick: \"Bob\",\n\t\t\t//\t|\t\t\tname: {\n\t\t\t//\t|\t\t\t\tfirst:\t\"Robert\",\n\t\t\t//\t|\t\t\t\tmiddle: \"X\",\n\t\t\t//\t|\t\t\t\tlast:\t\t\"Cringely\"\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t});\n\t\t\t//\t|\t// returns: Hello, Robert Cringely AKA Bob!\n\t\t\t// example:\n\t\t\t//\t|\t// uses an array for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, {0} {2}!\",\n\t\t\t//\t|\t\t[\"Robert\", \"X\", \"Cringely\"]);\n\t\t\t//\t|\t// returns: Hello, Robert Cringely!\n\t\t\t// example:\n\t\t\t//\t|\t// uses a function for substitutions:\n\t\t\t//\t|\tfunction sum(a){\n\t\t\t//\t|\t\tvar t = 0;\n\t\t\t//\t|\t\tarrayforEach(a, function(x){ t += x; });\n\t\t\t//\t|\t\treturn t;\n\t\t\t//\t|\t}\n\t\t\t//\t|\tlang.replace(\n\t\t\t//\t|\t\t\"{count} payments averaging {avg} USD per payment.\",\n\t\t\t//\t|\t\tlang.hitch(\n\t\t\t//\t|\t\t\t{ payments: [11, 16, 12] },\n\t\t\t//\t|\t\t\tfunction(_, key){\n\t\t\t//\t|\t\t\t\tswitch(key){\n\t\t\t//\t|\t\t\t\t\tcase \"count\": return this.payments.length;\n\t\t\t//\t|\t\t\t\t\tcase \"min\":\t\treturn Math.min.apply(Math, this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"max\":\t\treturn Math.max.apply(Math, this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"sum\":\t\treturn sum(this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"avg\":\t\treturn sum(this.payments) / this.payments.length;\n\t\t\t//\t|\t\t\t\t}\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t)\n\t\t\t//\t|\t);\n\t\t\t//\t|\t// prints: 3 payments averaging 13 USD per payment.\n\t\t\t// example:\n\t\t\t//\t|\t// uses an alternative PHP-like pattern for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, ${0} ${2}!\",\n\t\t\t//\t|\t\t[\"Robert\", \"X\", \"Cringely\"], /\\$\\{([^\\}]+)\\}/g);\n\t\t\t//\t|\t// returns: Hello, Robert Cringely!\n\n\t\t\treturn tmpl.replace(pattern || _pattern, lang.isFunction(map) ?\n\t\t\t\tmap : function(_, k){ return lang.getObject(k, false, map); });\n\t\t}\n\t};\n\n\thas(\"extend-dojo\") && lang.mixin(dojo, lang);\n\n\treturn lang;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/lang.js?");

/***/ }),

/***/ "./node_modules/dojo/global.js":
/*!*************************************!*\
  !*** ./node_modules/dojo/global.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){\n    if (typeof global !== 'undefined' && typeof global !== 'function') {\n        // global spec defines a reference to the global object called 'global'\n        // https://github.com/tc39/proposal-global\n        // `global` is also defined in NodeJS\n        return global;\n    }\n    else if (typeof window !== 'undefined') {\n        // window is defined in browsers\n        return window;\n    }\n    else if (typeof self !== 'undefined') {\n        // self is defined in WebWorkers\n        return self;\n    }\n    return this;\n}).call(null, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/global.js?");

/***/ }),

/***/ "./node_modules/dojo/has.js":
/*!**********************************!*\
  !*** ./node_modules/dojo/has.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./global */ \"./node_modules/dojo/global.js\"), __webpack_require__.dj.c(module.i), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, require, module){\n\t// module:\n\t//\t\tdojo/has\n\t// summary:\n\t//\t\tDefines the has.js API and several feature tests used by dojo.\n\t// description:\n\t//\t\tThis module defines the has API as described by the project has.js with the following additional features:\n\t//\n\t//\t\t- the has test cache is exposed at has.cache.\n\t//\t\t- the method has.add includes a forth parameter that controls whether or not existing tests are replaced\n\t//\t\t- the loader's has cache may be optionally copied into this module's has cahce.\n\t//\n\t//\t\tThis module adopted from https://github.com/phiggins42/has.js; thanks has.js team!\n\n\t// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one\n\t// if using a foreign loader, then the has cache may be initialized via the config object for this module\n\t// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail\n\tvar has = require.has || function(){};\n\tif(!has(\"dojo-has-api\")){\n\t\tvar\n\t\t\tisBrowser =\n\t\t\t\t// the most fundamental decision: are we in the browser?\n\t\t\t\ttypeof window != \"undefined\" &&\n\t\t\t\ttypeof location != \"undefined\" &&\n\t\t\t\ttypeof document != \"undefined\" &&\n\t\t\t\twindow.location == location && window.document == document,\n\n\t\t\t// has API variables\n\t\t\tdoc = isBrowser && document,\n\t\t\telement = doc && doc.createElement(\"DiV\"),\n\t\t\tcache = (module.config && module.config()) || {};\n\n\t\thas = function(name){\n\t\t\t// summary:\n\t\t\t//\t\tReturn the current value of the named feature.\n\t\t\t//\n\t\t\t// name: String|Integer\n\t\t\t//\t\tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t//\n\t\t\t// description:\n\t\t\t//\t\tReturns the value of the feature named by name. The feature must have been\n\t\t\t//\t\tpreviously added to the cache by has.add.\n\n\t\t\treturn typeof cache[name] == \"function\" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean\n\t\t};\n\n\t\thas.cache = cache;\n\n\t\thas.add = function(name, test, now, force){\n\t\t\t// summary:\n\t\t\t//\t \tRegister a new feature test for some named feature.\n\t\t\t// name: String|Integer\n\t\t\t//\t \tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t// test: Function\n\t\t\t//\t\t A test function to register. If a function, queued for testing until actually\n\t\t\t//\t\t needed. The test function should return a boolean indicating\n\t\t\t//\t \tthe presence of a feature or bug.\n\t\t\t// now: Boolean?\n\t\t\t//\t\t Optional. Omit if `test` is not a function. Provides a way to immediately\n\t\t\t//\t\t run the test and cache the result.\n\t\t\t// force: Boolean?\n\t\t\t//\t \tOptional. If the test already exists and force is truthy, then the existing\n\t\t\t//\t \ttest will be replaced; otherwise, add does not replace an existing test (that\n\t\t\t//\t \tis, by default, the first test advice wins).\n\t\t\t// example:\n\t\t\t//\t\tA redundant test, testFn with immediate execution:\n\t\t\t//\t|\thas.add(\"javascript\", function(){ return true; }, true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAgain with the redundantness. You can do this in your tests, but we should\n\t\t\t//\t\tnot be doing this in any internal has.js tests\n\t\t\t//\t|\thas.add(\"javascript\", true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tThree things are passed to the testFunction. `global`, `document`, and a generic element\n\t\t\t//\t\tfrom which to work your test should the need arise.\n\t\t\t//\t|\thas.add(\"bug-byid\", function(g, d, el){\n\t\t\t//\t|\t\t// g\t== global, typically window, yadda yadda\n\t\t\t//\t|\t\t// d\t== document object\n\t\t\t//\t|\t\t// el == the generic element. a `has` element.\n\t\t\t//\t|\t\treturn false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer\n\t\t\t//\t|\t});\n\n\t\t\t(typeof cache[name]==\"undefined\" || force) && (cache[name]= test);\n\t\t\treturn now && has(name);\n\t\t};\n\n\t\t// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize\n\t\t// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder\n\t\t// can optimize these away iff desired\n\t\thas.add(\"host-browser\", isBrowser);\n\t\thas.add(\"host-node\", (typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\t\thas.add(\"host-rhino\", (typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\t\thas.add(\"dom\", isBrowser);\n\t\thas.add(\"dojo-dom-ready-api\", 1);\n\t\thas.add(\"dojo-sniff\", 1);\n\t}\n\n\tif(has(\"host-browser\")){\n\t\t// Common application level tests\n\t\thas.add(\"dom-addeventlistener\", !!document.addEventListener);\n\n\t\t// Do the device and browser have touch capability?\n\t\thas.add(\"touch\", \"ontouchstart\" in document\n\t\t\t|| (\"onpointerdown\" in document && navigator.maxTouchPoints > 0)\n\t\t\t|| window.navigator.msMaxTouchPoints);\n\n\t\t// Touch events support\n\t\thas.add(\"touch-events\", \"ontouchstart\" in document);\n\n\t\t// Test if pointer events are supported and enabled, with either standard names (\"pointerdown\" etc.) or\n\t\t// IE specific names (\"MSPointerDown\" etc.).  Tests are designed to work on embedded C# WebBrowser Controls\n\t\t// in addition to IE, Edge, and future versions of Firefox and Chrome.\n\t\t// Note that on IE11, has(\"pointer-events\") and has(\"MSPointer\") are both true.\n\t\thas.add(\"pointer-events\", \"pointerEnabled\" in window.navigator ?\n\t\t\t\twindow.navigator.pointerEnabled : \"PointerEvent\" in window);\n\t\thas.add(\"MSPointer\", window.navigator.msPointerEnabled);\n\t\t// The \"pointermove\"\" event is only continuously emitted in a touch environment if\n\t\t// the target node's \"touch-action\"\" CSS property is set to \"none\"\n\t\t// https://www.w3.org/TR/pointerevents/#the-touch-action-css-property\n\t\thas.add(\"touch-action\", has(\"touch\") && has(\"pointer-events\"));\n\n\t\t// I don't know if any of these tests are really correct, just a rough guess\n\t\thas.add(\"device-width\", screen.availWidth || innerWidth);\n\n\t\t// Tests for DOMNode.attributes[] behavior:\n\t\t//\t - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes\n\t\t//\t - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify\n\t\t//\t - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.\n\t\tvar form = document.createElement(\"form\");\n\t\thas.add(\"dom-attributes-explicit\", form.attributes.length == 0); // W3C\n\t\thas.add(\"dom-attributes-specified-flag\", form.attributes.length > 0 && form.attributes.length < 40);\t// IE8\n\t}\n\n\thas.clearElement = function(element){\n\t\t// summary:\n\t\t//\t Deletes the contents of the element passed to test functions.\n\t\telement.innerHTML= \"\";\n\t\treturn element;\n\t};\n\n\thas.normalize = function(id, toAbsMid){\n\t\t// summary:\n\t\t//\t Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).\n\t\t//\n\t\t// toAbsMid: Function\n\t\t//\t Resolves a relative module id into an absolute module id\n\t\tvar\n\t\t\ttokens = id.match(/[\\?:]|[^:\\?]*/g), i = 0,\n\t\t\tget = function(skip){\n\t\t\t\tvar term = tokens[i++];\n\t\t\t\tif(term == \":\"){\n\t\t\t\t\t// empty string module name, resolves to 0\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\t// postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t\t\t\t\tif(tokens[i++] == \"?\"){\n\t\t\t\t\t\tif(!skip && has(term)){\n\t\t\t\t\t\t\t// matched the feature, get the first value from the options\n\t\t\t\t\t\t\treturn get();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// did not match, get the second value, passing over the first\n\t\t\t\t\t\t\tget(true);\n\t\t\t\t\t\t\treturn get(skip);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// a module\n\t\t\t\t\treturn term || 0;\n\t\t\t\t}\n\t\t\t};\n\t\tid = get();\n\t\treturn id && toAbsMid(id);\n\t};\n\n\thas.load = function(id, parentRequire, loaded){\n\t\t// summary:\n\t\t//\t\tConditional loading of AMD modules based on a has feature test value.\n\t\t// id: String\n\t\t//\t\tGives the resolved module id to load.\n\t\t// parentRequire: Function\n\t\t//\t\tThe loader require function with respect to the module that contained the plugin resource in it's\n\t\t//\t\tdependency list.\n\t\t// loaded: Function\n\t\t//\t Callback to loader that consumes result of plugin demand.\n\n\t\tif(id){\n\t\t\tparentRequire([id], loaded);\n\t\t}else{\n\t\t\tloaded();\n\t\t}\n\t};\n\n\treturn has;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/has.js?");

/***/ }),

/***/ "./node_modules/dojo/sniff.js":
/*!************************************!*\
  !*** ./node_modules/dojo/sniff.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./has */ \"./node_modules/dojo/has.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has){\n\t// module:\n\t//\t\tdojo/sniff\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tThis module sets has() flags based on the current browser.\n\t\t//\t\tIt returns the has() function.\n\t};\n\t=====*/\n\n\tif(has(\"host-browser\")){\n\t\tvar n = navigator,\n\t\t\tdua = n.userAgent,\n\t\t\tdav = n.appVersion,\n\t\t\ttv = parseFloat(dav);\n\t\thas.add(\"air\", dua.indexOf(\"AdobeAIR\") >= 0);\n\t\thas.add(\"wp\", parseFloat(dua.split(\"Windows Phone\")[1]) || undefined);\n\t\thas.add(\"msapp\", parseFloat(dua.split(\"MSAppHost/\")[1]) || undefined);\n\t\thas.add(\"khtml\", dav.indexOf(\"Konqueror\") >= 0 ? tv : undefined);\n\t\thas.add(\"edge\", parseFloat(dua.split(\"Edge/\")[1]) || undefined);\n\t\thas.add(\"opr\", parseFloat(dua.split(\"OPR/\")[1]) || undefined);\n\t\t// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/\n\t\thas.add(\"webkit\", !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540\n\t\t\t&& !has(\"edge\") && parseFloat(dua.split(\"WebKit/\")[1]) || undefined);\n\t\thas.add(\"chrome\", !has(\"edge\") && !has(\"opr\")\n\t\t\t\t&& parseFloat(dua.split(\"Chrome/\")[1]) || undefined);\n\t\thas.add(\"android\", !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528\n\t\t\t\t&& parseFloat(dua.split(\"Android \")[1]) || undefined);\n\t\thas.add(\"safari\", dav.indexOf(\"Safari\") >= 0\n\t\t\t\t&& !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540\n\t\t\t\t&& !has(\"chrome\") && !has(\"android\") && !has(\"edge\") && !has(\"opr\") ?\n\t\t\tparseFloat(dav.split(\"Version/\")[1]) : undefined);\n\t\thas.add(\"mac\", dav.indexOf(\"Macintosh\") >= 0);\n\t\thas.add(\"quirks\", document.compatMode == \"BackCompat\");\n\t\tif(!has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528\n\t\t\t\t&& dua.match(/(iPhone|iPod|iPad)/)){\n\t\t\tvar p = RegExp.$1.replace(/P/, \"p\");\n\t\t\tvar v = dua.match(/OS ([\\d_]+)/) ? RegExp.$1 : \"1\";\n\t\t\tvar os = parseFloat(v.replace(/_/, \".\").replace(/_/g, \"\"));\n\t\t\thas.add(p, os);\t\t// \"iphone\", \"ipad\" or \"ipod\"\n\t\t\thas.add(\"ios\", os);\n\t\t}\n\t\thas.add(\"bb\", (dua.indexOf(\"BlackBerry\") >= 0 || dua.indexOf(\"BB10\") >= 0) && parseFloat(dua.split(\"Version/\")[1]) || undefined);\n\t\thas.add(\"trident\", parseFloat(dav.split(\"Trident/\")[1]) || undefined);\n\n\t\thas.add(\"svg\", typeof SVGAngle !== \"undefined\");\n\n\t\tif(!has(\"webkit\")){\n\t\t\t// Opera\n\t\t\tif(dua.indexOf(\"Opera\") >= 0){\n\t\t\t\t// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/\n\t\t\t\t// 9.8 has both styles; <9.8, 9.9 only old style\n\t\t\t\thas.add(\"opera\", tv >= 9.8 ? parseFloat(dua.split(\"Version/\")[1]) || tv : tv);\n\t\t\t}\n\n\t\t\t// Mozilla and firefox\n\t\t\tif(dua.indexOf(\"Gecko\") >= 0 && !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1\n\t\t\t\t\t&& !has(\"khtml\") && !has(\"trident\") && !has(\"edge\")){\n\t\t\t\thas.add(\"mozilla\", tv);\n\t\t\t}\n\t\t\tif(has(\"mozilla\")){\n\t\t\t\t//We really need to get away from this. Consider a sane isGecko approach for the future.\n\t\t\t\thas.add(\"ff\", parseFloat(dua.split(\"Firefox/\")[1] || dua.split(\"Minefield/\")[1]) || undefined);\n\t\t\t}\n\n\t\t\t// IE\n\t\t\tif(document.all && !has(\"opera\")){\n\t\t\t\tvar isIE = parseFloat(dav.split(\"MSIE \")[1]) || undefined;\n\n\t\t\t\t//In cases where the page has an HTTP header or META tag with\n\t\t\t\t//X-UA-Compatible, then it is in emulation mode.\n\t\t\t\t//Make sure isIE reflects the desired version.\n\t\t\t\t//document.documentMode of 5 means quirks mode.\n\t\t\t\t//Only switch the value if documentMode's major version\n\t\t\t\t//is different from isIE's major version.\n\t\t\t\tvar mode = document.documentMode;\n\t\t\t\tif(mode && mode != 5 && Math.floor(isIE) != mode){\n\t\t\t\t\tisIE = mode;\n\t\t\t\t}\n\n\t\t\t\thas.add(\"ie\", isIE);\n\t\t\t}\n\n\t\t\t// Wii\n\t\t\thas.add(\"wii\", typeof opera != \"undefined\" && opera.wiiremote);\n\t\t}\n\t}\n\n\treturn has;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/sniff.js?");

/***/ })

}]);