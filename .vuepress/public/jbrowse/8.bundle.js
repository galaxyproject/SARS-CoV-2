(function(){
(this||window)["webpackJsonp"].registerAbsMids({
	// "./arrayWithHoles" = "./node_modules/@babel/runtime/helpers/arrayWithHoles.js"
	// "./arrayWithoutHoles" = "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"
	// "@babel/runtime/helpers/asyncToGenerator" = "./node_modules/@babel/runtime/helpers/asyncToGenerator.js"
	// "@babel/runtime/helpers/classCallCheck" = "./node_modules/@babel/runtime/helpers/classCallCheck.js"
	// "@babel/runtime/helpers/createClass" = "./node_modules/@babel/runtime/helpers/createClass.js"
	// "@babel/runtime/helpers/interopRequireDefault" = "./node_modules/@babel/runtime/helpers/interopRequireDefault.js"
	// "./iterableToArray" = "./node_modules/@babel/runtime/helpers/iterableToArray.js"
	// "./iterableToArrayLimit" = "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"
	// "./nonIterableRest" = "./node_modules/@babel/runtime/helpers/nonIterableRest.js"
	// "./nonIterableSpread" = "./node_modules/@babel/runtime/helpers/nonIterableSpread.js"
	// "@babel/runtime/helpers/slicedToArray" = "./node_modules/@babel/runtime/helpers/slicedToArray.js"
	// "@babel/runtime/helpers/toConsumableArray" = "./node_modules/@babel/runtime/helpers/toConsumableArray.js"
	// "@babel/runtime/regenerator" = "./node_modules/@babel/runtime/regenerator/index.js"
	// "abortcontroller-polyfill/dist/cjs-ponyfill" = "./node_modules/abortcontroller-polyfill/dist/cjs-ponyfill.js"
	// "./abortcontroller-ponyfill" = "./node_modules/http-range-fetcher/dist/abortcontroller-ponyfill.js"
	// "./aggregatingFetcher" = "./node_modules/http-range-fetcher/dist/aggregatingFetcher.js"
	// "./cacheSemantics" = "./node_modules/http-range-fetcher/dist/cacheSemantics.js"
	// "./crossFetchBinaryRange" = "./node_modules/http-range-fetcher/dist/crossFetchBinaryRange.js"
	// "./httpRangeFetcher" = "./node_modules/http-range-fetcher/dist/httpRangeFetcher.js"
	// "http-range-fetcher" = "./node_modules/http-range-fetcher/dist/index.js"
	// "cross-fetch" = "./node_modules/http-range-fetcher/node_modules/cross-fetch/dist/browser-ponyfill.js"
	// "./entries" = "./node_modules/object.entries-ponyfill/entries.js"
	// "object.entries-ponyfill" = "./node_modules/object.entries-ponyfill/index.js"
	// "quick-lru" = "./node_modules/quick-lru/index.js"
	// "regenerator-runtime" = "./node_modules/regenerator-runtime/runtime.js"
	// "tenacious-fetch" = "./node_modules/tenacious-fetch/dist/tenacious-fetch.m.js"
	// "whatwg-fetch" = "./node_modules/whatwg-fetch/fetch.js"
})
})(),(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[8],{

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/arrayWithHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/asyncToGenerator.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/classCallCheck.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/createClass.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/iterableToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/nonIterableRest.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/nonIterableSpread.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ \"./node_modules/@babel/runtime/helpers/arrayWithHoles.js\");\n\nvar iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ \"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js\");\n\nvar nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ \"./node_modules/@babel/runtime/helpers/nonIterableRest.js\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/slicedToArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ \"./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js\");\n\nvar iterableToArray = __webpack_require__(/*! ./iterableToArray */ \"./node_modules/@babel/runtime/helpers/iterableToArray.js\");\n\nvar nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ \"./node_modules/@babel/runtime/helpers/nonIterableSpread.js\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/helpers/toConsumableArray.js?");

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n\n\n//# sourceURL=webpack:///./node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "./node_modules/abortcontroller-polyfill/dist/cjs-ponyfill.js":
/*!********************************************************************!*\
  !*** ./node_modules/abortcontroller-polyfill/dist/cjs-ponyfill.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nvar Emitter =\n/*#__PURE__*/\nfunction () {\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n\n    Object.defineProperty(this, 'listeners', {\n      value: {},\n      writable: true,\n      configurable: true\n    });\n  }\n\n  _createClass(Emitter, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, callback) {\n      if (!(type in this.listeners)) {\n        this.listeners[type] = [];\n      }\n\n      this.listeners[type].push(callback);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, callback) {\n      if (!(type in this.listeners)) {\n        return;\n      }\n\n      var stack = this.listeners[type];\n\n      for (var i = 0, l = stack.length; i < l; i++) {\n        if (stack[i] === callback) {\n          stack.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      var _this = this;\n\n      if (!(event.type in this.listeners)) {\n        return;\n      }\n\n      var debounce = function debounce(callback) {\n        setTimeout(function () {\n          return callback.call(_this, event);\n        });\n      };\n\n      var stack = this.listeners[event.type];\n\n      for (var i = 0, l = stack.length; i < l; i++) {\n        debounce(stack[i]);\n      }\n\n      return !event.defaultPrevented;\n    }\n  }]);\n\n  return Emitter;\n}();\n\nvar AbortSignal =\n/*#__PURE__*/\nfunction (_Emitter) {\n  _inherits(AbortSignal, _Emitter);\n\n  function AbortSignal() {\n    var _this2;\n\n    _classCallCheck(this, AbortSignal);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AbortSignal).call(this)); // Some versions of babel does not transpile super() correctly for IE <= 10, if the parent\n    // constructor has failed to run, then \"this.listeners\" will still be undefined and then we call\n    // the parent constructor directly instead as a workaround. For general details, see babel bug:\n    // https://github.com/babel/babel/issues/3041\n    // This hack was added as a fix for the issue described here:\n    // https://github.com/Financial-Times/polyfill-library/pull/59#issuecomment-477558042\n\n    if (!_this2.listeners) {\n      Emitter.call(_assertThisInitialized(_this2));\n    } // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n    // we want Object.keys(new AbortController().signal) to be [] for compat with the native impl\n\n\n    Object.defineProperty(_assertThisInitialized(_this2), 'aborted', {\n      value: false,\n      writable: true,\n      configurable: true\n    });\n    Object.defineProperty(_assertThisInitialized(_this2), 'onabort', {\n      value: null,\n      writable: true,\n      configurable: true\n    });\n    return _this2;\n  }\n\n  _createClass(AbortSignal, [{\n    key: \"toString\",\n    value: function toString() {\n      return '[object AbortSignal]';\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      if (event.type === 'abort') {\n        this.aborted = true;\n\n        if (typeof this.onabort === 'function') {\n          this.onabort.call(this, event);\n        }\n      }\n\n      _get(_getPrototypeOf(AbortSignal.prototype), \"dispatchEvent\", this).call(this, event);\n    }\n  }]);\n\n  return AbortSignal;\n}(Emitter);\nvar AbortController =\n/*#__PURE__*/\nfunction () {\n  function AbortController() {\n    _classCallCheck(this, AbortController);\n\n    // Compared to assignment, Object.defineProperty makes properties non-enumerable by default and\n    // we want Object.keys(new AbortController()) to be [] for compat with the native impl\n    Object.defineProperty(this, 'signal', {\n      value: new AbortSignal(),\n      writable: true,\n      configurable: true\n    });\n  }\n\n  _createClass(AbortController, [{\n    key: \"abort\",\n    value: function abort() {\n      var event;\n\n      try {\n        event = new Event('abort');\n      } catch (e) {\n        if (typeof document !== 'undefined') {\n          if (!document.createEvent) {\n            // For Internet Explorer 8:\n            event = document.createEventObject();\n            event.type = 'abort';\n          } else {\n            // For Internet Explorer 11:\n            event = document.createEvent('Event');\n            event.initEvent('abort', false, false);\n          }\n        } else {\n          // Fallback where document isn't available:\n          event = {\n            type: 'abort',\n            bubbles: false,\n            cancelable: false\n          };\n        }\n      }\n\n      this.signal.dispatchEvent(event);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '[object AbortController]';\n    }\n  }]);\n\n  return AbortController;\n}();\n\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n  // These are necessary to make sure that we get correct output for:\n  // Object.prototype.toString.call(new AbortController())\n  AbortController.prototype[Symbol.toStringTag] = 'AbortController';\n  AbortSignal.prototype[Symbol.toStringTag] = 'AbortSignal';\n}\n\nfunction polyfillNeeded(self) {\n  if (self.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n    console.log('__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill');\n    return true;\n  } // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n  // defining window.Request, and this polyfill need to work on top of unfetch\n  // so the below feature detection needs the !self.AbortController part.\n  // The Request.prototype check is also needed because Safari versions 11.1.2\n  // up to and including 12.1.x has a window.AbortController present but still\n  // does NOT correctly implement abortable fetch:\n  // https://bugs.webkit.org/show_bug.cgi?id=174980#c2\n\n\n  return typeof self.Request === 'function' && !self.Request.prototype.hasOwnProperty('signal') || !self.AbortController;\n}\n\n/**\n * Note: the \"fetch.Request\" default value is available for fetch imported from\n * the \"node-fetch\" package and not in browsers. This is OK since browsers\n * will be importing umd-polyfill.js from that path \"self\" is passed the\n * decorator so the default value will not be used (because browsers that define\n * fetch also has Request). One quirky setup where self.fetch exists but\n * self.Request does not is when the \"unfetch\" minimal fetch polyfill is used\n * on top of IE11; for this case the browser will try to use the fetch.Request\n * default value which in turn will be undefined but then then \"if (Request)\"\n * will ensure that you get a patched fetch but still no Request (as expected).\n * @param {fetch, Request = fetch.Request}\n * @returns {fetch: abortableFetch, Request: AbortableRequest}\n */\n\nfunction abortableFetchDecorator(patchTargets) {\n  if ('function' === typeof patchTargets) {\n    patchTargets = {\n      fetch: patchTargets\n    };\n  }\n\n  var _patchTargets = patchTargets,\n      fetch = _patchTargets.fetch,\n      _patchTargets$Request = _patchTargets.Request,\n      NativeRequest = _patchTargets$Request === void 0 ? fetch.Request : _patchTargets$Request,\n      NativeAbortController = _patchTargets.AbortController,\n      _patchTargets$__FORCE = _patchTargets.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL,\n      __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL = _patchTargets$__FORCE === void 0 ? false : _patchTargets$__FORCE;\n\n  if (!polyfillNeeded({\n    fetch: fetch,\n    Request: NativeRequest,\n    AbortController: NativeAbortController,\n    __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL\n  })) {\n    return {\n      fetch: fetch,\n      Request: Request\n    };\n  }\n\n  var Request = NativeRequest; // Note that the \"unfetch\" minimal fetch polyfill defines fetch() without\n  // defining window.Request, and this polyfill need to work on top of unfetch\n  // hence we only patch it if it's available. Also we don't patch it if signal\n  // is already available on the Request prototype because in this case support\n  // is present and the patching below can cause a crash since it assigns to\n  // request.signal which is technically a read-only property. This latter error\n  // happens when you run the main5.js node-fetch example in the repo\n  // \"abortcontroller-polyfill-examples\". The exact error is:\n  //   request.signal = init.signal;\n  //   ^\n  // TypeError: Cannot set property signal of #<Request> which has only a getter\n\n  if (Request && !Request.prototype.hasOwnProperty('signal') || __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {\n    Request = function Request(input, init) {\n      var signal;\n\n      if (init && init.signal) {\n        signal = init.signal; // Never pass init.signal to the native Request implementation when the polyfill has\n        // been installed because if we're running on top of a browser with a\n        // working native AbortController (i.e. the polyfill was installed due to\n        // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n        // fake AbortSignal to the native fetch will trigger:\n        // TypeError: Failed to construct 'Request': member signal is not of type AbortSignal.\n\n        delete init.signal;\n      }\n\n      var request = new NativeRequest(input, init);\n\n      if (signal) {\n        Object.defineProperty(request, 'signal', {\n          writable: false,\n          enumerable: false,\n          configurable: true,\n          value: signal\n        });\n      }\n\n      return request;\n    };\n\n    Request.prototype = NativeRequest.prototype;\n  }\n\n  var realFetch = fetch;\n\n  var abortableFetch = function abortableFetch(input, init) {\n    var signal = Request && Request.prototype.isPrototypeOf(input) ? input.signal : init ? init.signal : undefined;\n\n    if (signal) {\n      var abortError;\n\n      try {\n        abortError = new DOMException('Aborted', 'AbortError');\n      } catch (err) {\n        // IE 11 does not support calling the DOMException constructor, use a\n        // regular error object on it instead.\n        abortError = new Error('Aborted');\n        abortError.name = 'AbortError';\n      } // Return early if already aborted, thus avoiding making an HTTP request\n\n\n      if (signal.aborted) {\n        return Promise.reject(abortError);\n      } // Turn an event into a promise, reject it once `abort` is dispatched\n\n\n      var cancellation = new Promise(function (_, reject) {\n        signal.addEventListener('abort', function () {\n          return reject(abortError);\n        }, {\n          once: true\n        });\n      });\n\n      if (init && init.signal) {\n        // Never pass .signal to the native implementation when the polyfill has\n        // been installed because if we're running on top of a browser with a\n        // working native AbortController (i.e. the polyfill was installed due to\n        // __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL being set), then passing our\n        // fake AbortSignal to the native fetch will trigger:\n        // TypeError: Failed to execute 'fetch' on 'Window': member signal is not of type AbortSignal.\n        delete init.signal;\n      } // Return the fastest promise (don't need to wait for request to finish)\n\n\n      return Promise.race([cancellation, realFetch(input, init)]);\n    }\n\n    return realFetch(input, init);\n  };\n\n  return {\n    fetch: abortableFetch,\n    Request: Request\n  };\n}\n\nexports.AbortController = AbortController;\nexports.AbortSignal = AbortSignal;\nexports.abortableFetch = abortableFetchDecorator;\n\n\n//# sourceURL=webpack:///./node_modules/abortcontroller-polyfill/dist/cjs-ponyfill.js?");

/***/ }),

/***/ "./node_modules/http-range-fetcher/dist/abortcontroller-ponyfill.js":
/*!**************************************************************************!*\
  !*** ./node_modules/http-range-fetcher/dist/abortcontroller-ponyfill.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* eslint-disable */\nif (typeof AbortController === 'undefined') {\n  var _require = __webpack_require__(/*! abortcontroller-polyfill/dist/cjs-ponyfill */ \"./node_modules/abortcontroller-polyfill/dist/cjs-ponyfill.js\"),\n      _AbortController = _require.AbortController,\n      _AbortSignal = _require.AbortSignal;\n\n  module.exports = {\n    AbortController: _AbortController,\n    AbortSignal: _AbortSignal\n  };\n} else {\n  module.exports = {\n    AbortController: AbortController,\n    AbortSignal: AbortSignal\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/http-range-fetcher/dist/abortcontroller-ponyfill.js?");

/***/ }),

/***/ "./node_modules/http-range-fetcher/dist/aggregatingFetcher.js":
/*!********************************************************************!*\
  !*** ./node_modules/http-range-fetcher/dist/aggregatingFetcher.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _slicedToArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/slicedToArray.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _object = _interopRequireDefault(__webpack_require__(/*! object.entries-ponyfill */ \"./node_modules/object.entries-ponyfill/index.js\"));\n\nvar _abortcontrollerPonyfill = __webpack_require__(/*! ./abortcontroller-ponyfill */ \"./node_modules/http-range-fetcher/dist/abortcontroller-ponyfill.js\");\n\n/**\n * takes fetch requests and aggregates them at a certain time frequency\n */\nvar AggregatingFetcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   *\n   * @param {object} params\n   * @param {number} [params.frequency] number of milliseconds to wait for requests to aggregate\n   */\n  function AggregatingFetcher(_ref) {\n    var _ref$frequency = _ref.frequency,\n        frequency = _ref$frequency === void 0 ? 100 : _ref$frequency,\n        fetch = _ref.fetch,\n        _ref$maxExtraSize = _ref.maxExtraSize,\n        maxExtraSize = _ref$maxExtraSize === void 0 ? 32000 : _ref$maxExtraSize,\n        _ref$maxFetchSize = _ref.maxFetchSize,\n        maxFetchSize = _ref$maxFetchSize === void 0 ? 1000000 : _ref$maxFetchSize;\n    (0, _classCallCheck2.default)(this, AggregatingFetcher);\n    this.requestQueues = {}; // url => array of requests\n\n    this.fetchCallback = fetch;\n    this.frequency = frequency;\n    this.maxExtraSize = maxExtraSize;\n    this.maxFetchSize = maxFetchSize;\n  }\n\n  (0, _createClass2.default)(AggregatingFetcher, [{\n    key: \"_canAggregate\",\n    value: function _canAggregate(requestGroup, request) {\n      return (// the fetches overlap, or come close\n        request.start <= requestGroup.end + this.maxExtraSize && // aggregating would not result in a fetch that is too big\n        request.end - request.start + requestGroup.end - requestGroup.start < this.maxFetchSize\n      );\n    } // returns a promise that only resolves\n    // when all of the signals in the given array\n    // have fired their abort signal\n\n  }, {\n    key: \"_allSignalsFired\",\n    value: function _allSignalsFired(signals) {\n      return new Promise(function (resolve) {\n        var signalsLeft = signals.filter(function (s) {\n          return !s.aborted;\n        }).length;\n        signals.forEach(function (signal) {\n          signal.addEventListener('abort', function () {\n            signalsLeft -= 1; // console.log('aggregatingfetcher received an abort')\n\n            if (!signalsLeft) {\n              // console.log('aggregatingfetcher aborting aggegated request')\n              resolve();\n            }\n          });\n        });\n      }).catch(function (e) {\n        console.error(e);\n      });\n    } // dispatch a request group as a single request\n    // and then slice the result back up to satisfy\n    // the individual requests\n\n  }, {\n    key: \"_dispatch\",\n    value: function _dispatch(_ref2) {\n      var url = _ref2.url,\n          start = _ref2.start,\n          end = _ref2.end,\n          requests = _ref2.requests;\n      // if any of the requests have an AbortSignal `signal` in their requestOptions,\n      // make our aggregating abortcontroller track it, aborting the request if\n      // all of the abort signals that are aggregated here have fired\n      var abortWholeRequest = new _abortcontrollerPonyfill.AbortController();\n      var signals = [];\n      requests.forEach(function (_ref3) {\n        var requestOptions = _ref3.requestOptions;\n        if (requestOptions && requestOptions.signal) signals.push(requestOptions.signal);\n      });\n\n      if (signals.length === requests.length) {\n        this._allSignalsFired(signals).then(function () {\n          return abortWholeRequest.abort();\n        });\n      }\n\n      this.fetchCallback(url, start, end - 1, {\n        signal: abortWholeRequest.signal\n      }).then(function (response) {\n        var data = response.buffer;\n        requests.forEach(function (_ref4) {\n          var reqStart = _ref4.start,\n              reqEnd = _ref4.end,\n              resolve = _ref4.resolve;\n          // remember Buffer.slice does not copy, it creates\n          // an offset child buffer pointing to the same data\n          resolve({\n            headers: response.headers,\n            buffer: data.slice(reqStart - start, reqEnd - start)\n          });\n        });\n      }, function (err) {\n        requests.forEach(function (_ref5) {\n          var reject = _ref5.reject;\n          return reject(err);\n        });\n      });\n    }\n  }, {\n    key: \"_aggregateAndDispatch\",\n    value: function _aggregateAndDispatch() {\n      var _this = this;\n\n      (0, _object.default)(this.requestQueues).forEach(function (_ref6) {\n        var _ref7 = (0, _slicedToArray2.default)(_ref6, 2),\n            url = _ref7[0],\n            requests = _ref7[1];\n\n        if (!requests || !requests.length) return; // console.log(url, requests)\n        // we are now going to aggregate the requests in this url's queue\n        // into groups of requests that can be dispatched as one\n\n        var requestsToDispatch = []; // look to see if any of the requests are aborted, and if they are, just\n        // reject them now and forget about them\n\n        requests.forEach(function (request) {\n          var requestOptions = request.requestOptions,\n              reject = request.reject;\n\n          if (requestOptions && requestOptions.signal && requestOptions.signal.aborted) {\n            reject(Object.assign(new Error('aborted'), {\n              code: 'ERR_ABORTED'\n            }));\n          } else {\n            requestsToDispatch.push(request);\n          }\n        });\n        requestsToDispatch.sort(function (a, b) {\n          return a.start - b.start;\n        });\n        requests.length = 0;\n        if (!requestsToDispatch.length) return;\n        var currentRequestGroup;\n\n        for (var i = 0; i < requestsToDispatch.length; i += 1) {\n          var next = requestsToDispatch[i];\n\n          if (currentRequestGroup && _this._canAggregate(currentRequestGroup, next)) {\n            // aggregate it into the current group\n            currentRequestGroup.requests.push(next);\n            currentRequestGroup.end = next.end;\n          } else {\n            // out of range, dispatch the current request group\n            if (currentRequestGroup) _this._dispatch(currentRequestGroup); // and start on a new one\n\n            currentRequestGroup = {\n              requests: [next],\n              url: url,\n              start: next.start,\n              end: next.end\n            };\n          }\n        }\n\n        if (currentRequestGroup) _this._dispatch(currentRequestGroup);\n      });\n    }\n  }, {\n    key: \"_enQueue\",\n    value: function _enQueue(url, request) {\n      if (!this.requestQueues[url]) this.requestQueues[url] = [];\n      this.requestQueues[url].push(request);\n    }\n    /**\n     *\n     * @param {string} url\n     * @param {number} start 0-based half-open\n     * @param {number} end 0-based half-open\n     * @param {object} [requestOptions] options passed to the underlying fetch call\n     */\n\n  }, {\n    key: \"fetch\",\n    value: function fetch(url, start, end) {\n      var _this2 = this;\n\n      var requestOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return new Promise(function (resolve, reject) {\n        _this2._enQueue(url, {\n          start: start,\n          end: end,\n          resolve: resolve,\n          reject: reject,\n          requestOptions: requestOptions\n        });\n\n        if (!_this2.timeout) {\n          _this2.timeout = setTimeout(function () {\n            _this2.timeout = undefined;\n\n            _this2._aggregateAndDispatch();\n          }, _this2.frequency || 1);\n        }\n      });\n    }\n  }]);\n  return AggregatingFetcher;\n}();\n\nmodule.exports = AggregatingFetcher;\n\n//# sourceURL=webpack:///./node_modules/http-range-fetcher/dist/aggregatingFetcher.js?");

/***/ }),

/***/ "./node_modules/http-range-fetcher/dist/cacheSemantics.js":
/*!****************************************************************!*\
  !*** ./node_modules/http-range-fetcher/dist/cacheSemantics.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nfunction parseCacheControl(field) {\n  if (typeof field !== 'string') {\n    return {};\n  }\n\n  var parsed = {};\n  var invalid = field.toLowerCase().replace( // eslint-disable-next-line no-control-regex,no-useless-escape\n  /(?:^|(?:\\s*,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, function (match, fieldName, three, four) {\n    var value = three || four;\n    parsed[fieldName] = value ? value.toLowerCase() : true;\n    return '';\n  });\n  if (invalid) return {}; // parse any things that seem to be numbers\n\n  Object.keys(parsed).forEach(function (key) {\n    if (/^[\\d]+$/.test(parsed[key])) {\n      try {\n        var num = parseInt(parsed[key], 10);\n\n        if (!Number.isNaN(num)) {\n          parsed[key] = num;\n        }\n      } catch (e) {\n        /* ignore */\n      }\n    }\n  });\n  return parsed;\n}\n\nvar CacheSemantics =\n/*#__PURE__*/\nfunction () {\n  function CacheSemantics(_ref) {\n    var minimumTTL = _ref.minimumTTL;\n    (0, _classCallCheck2.default)(this, CacheSemantics);\n    this.minimumTTL = minimumTTL;\n  }\n\n  (0, _createClass2.default)(CacheSemantics, [{\n    key: \"calculateChunkExpirationDate\",\n    value: function calculateChunkExpirationDate(chunkResponse) {\n      var _chunkResponse$header = chunkResponse.headers,\n          headers = _chunkResponse$header === void 0 ? {} : _chunkResponse$header,\n          requestDate = chunkResponse.requestDate,\n          responseDate = chunkResponse.responseDate;\n      var baselineDate = responseDate || requestDate;\n\n      if (!baselineDate) {\n        if (!headers.date) return undefined;\n        baselineDate = new Date(headers.date);\n      }\n\n      var basePlus = function basePlus(ttl) {\n        return new Date(baselineDate.getTime() + ttl);\n      }; // results that are not really cacheable expire after the minimum time to live\n\n\n      if (/\\bno-cache\\b/.test(headers.pragma)) return basePlus(this.minimumTTL);\n      var cacheControl = parseCacheControl(headers['cache-control']);\n      if (cacheControl['no-cache'] || cacheControl['no-store'] || cacheControl['must-revalidate']) return basePlus(this.minimumTTL);\n\n      if (cacheControl['max-age'] !== undefined) {\n        var ttl = cacheControl['max-age'] * 1000; // max-age is in seconds\n\n        return basePlus(Math.max(ttl, this.minimumTTL));\n      } else if (this._coerceToDate(headers.expires)) {\n        return this._coerceToDate(headers.expires);\n      } else if (this._coerceToDate(headers['last-modified'])) {\n        var lastModified = this._coerceToDate(headers['last-modified']);\n\n        var _ttl = (baselineDate.getTime() - lastModified.getTime()) / 10;\n\n        return basePlus(_ttl);\n      } // otherwise, we just cache forever\n\n\n      return undefined;\n    }\n  }, {\n    key: \"_coerceToDate\",\n    value: function _coerceToDate(thing) {\n      if (thing) {\n        if (thing instanceof Date) return thing;\n        if (typeof thing === 'string' || typeof thing === 'number') return new Date(thing);\n      }\n\n      return undefined;\n    }\n    /**\n     * check whether a cached chunk response is still valid and can be used\n     * @param {object} chunkResponse\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"cachedChunkIsValid\",\n    value: function cachedChunkIsValid(chunkResponse) {\n      var expiration = this.calculateChunkExpirationDate(chunkResponse);\n      return !expiration || new Date() <= expiration;\n    }\n    /**\n     * check whether the response for this chunk fetch can be cached\n     * @param {object} chunkResponse\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"chunkIsCacheable\",\n    value: function chunkIsCacheable() {\n      // right now, we are caching everything, we just give it a very short\n      // time to live if it's not supposed to be cached\n      return true;\n    }\n  }]);\n  return CacheSemantics;\n}();\n\nmodule.exports = {\n  CacheSemantics: CacheSemantics,\n  parseCacheControl: parseCacheControl\n};\n\n//# sourceURL=webpack:///./node_modules/http-range-fetcher/dist/cacheSemantics.js?");

/***/ }),

/***/ "./node_modules/http-range-fetcher/dist/crossFetchBinaryRange.js":
/*!***********************************************************************!*\
  !*** ./node_modules/http-range-fetcher/dist/crossFetchBinaryRange.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nvar crossFetch = __webpack_require__(/*! cross-fetch */ \"./node_modules/http-range-fetcher/node_modules/cross-fetch/dist/browser-ponyfill.js\");\n\nfunction crossFetchBinaryRange(url, start, end) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var requestDate = new Date();\n  var fetchOptions = Object.assign({\n    method: 'GET',\n    headers: {\n      range: \"bytes=\".concat(start, \"-\").concat(end)\n    }\n  }, options);\n  return crossFetch(url, fetchOptions).then(function (res) {\n    var responseDate = new Date();\n    if (res.status !== 206 && res.status !== 200) throw new Error(\"HTTP \".concat(res.status, \" when fetching \").concat(url, \" bytes \").concat(start, \"-\").concat(end));\n\n    if (res.status === 200) {\n      // TODO: check that the response satisfies the byte range,\n      // and is not too big (check maximum size),\n      // because we actually ended up getting served the whole file\n      throw new Error(\"HTTP \".concat(res.status, \" when fetching \").concat(url, \" bytes \").concat(start, \"-\").concat(end));\n    }\n\n    var bufPromise = res.buffer ? res.buffer() : res.arrayBuffer().then(function (arrayBuffer) {\n      return Buffer.from(arrayBuffer);\n    }); // return the response headers, and the data buffer\n\n    return bufPromise.then(function (buffer) {\n      return {\n        headers: res.headers.map,\n        requestDate: requestDate,\n        responseDate: responseDate,\n        buffer: buffer\n      };\n    });\n  });\n}\n\nmodule.exports = crossFetchBinaryRange;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/http-range-fetcher/dist/crossFetchBinaryRange.js?");

/***/ }),

/***/ "./node_modules/http-range-fetcher/dist/httpRangeFetcher.js":
/*!******************************************************************!*\
  !*** ./node_modules/http-range-fetcher/dist/httpRangeFetcher.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nvar _toConsumableArray2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/toConsumableArray.js\"));\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar LRU = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n\nvar _require = __webpack_require__(/*! ./cacheSemantics */ \"./node_modules/http-range-fetcher/dist/cacheSemantics.js\"),\n    CacheSemantics = _require.CacheSemantics;\n\nvar AggregatingFetcher = __webpack_require__(/*! ./aggregatingFetcher */ \"./node_modules/http-range-fetcher/dist/aggregatingFetcher.js\");\n\nvar crossFetchBinaryRange = __webpack_require__(/*! ./crossFetchBinaryRange */ \"./node_modules/http-range-fetcher/dist/crossFetchBinaryRange.js\");\n/**\n * check if the given exception was caused by an operation being intentionally aborted\n * @param {Error} exception\n * @returns {boolean}\n */\n\n\nfunction isAbortException(exception) {\n  return (// DOMException\n    exception.name === 'AbortError' || // standard-ish non-DOM abort exception\n    // @ts-ignore\n    exception.code === 'ERR_ABORTED' || // message contains aborted for bubbling through RPC\n    // things we have seen that we want to catch here\n    // Error: aborted\n    // AbortError: aborted\n    // AbortError: The user aborted a request.\n    !!exception.message.match(/\\b(aborted|AbortError)\\b/i)\n  );\n} // TODO: fire events when a remote file is detected as having been changed\n\n/**\n * smart cache that fetches chunks of remote files.\n * caches chunks in an LRU cache, and aggregates upstream fetches\n */\n\n\nvar HttpRangeFetcher =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {object} args the arguments object\n   * @param {number} [args.fetch] callback with signature `(key, start, end) => Promise({ headers, buffer })`\n   * @param {number} [args.size] size in bytes of cache to keep\n   * @param {number} [args.chunkSize] size in bytes of cached chunks\n   * @param {number} [args.aggregationTime] time in ms over which to pool requests before dispatching them\n   * @param {number} [args.minimumTTL] time in ms a non-cacheable response will be cached\n   * @param {number} [args.maxFetchSize] maximum size of an aggregated request\n   * @param {number} [args.maxExtraFetch] max number of additional bytes to fetch when aggregating requests\n   * that don't actually overlap\n   */\n  function HttpRangeFetcher(_ref) {\n    var _ref$fetch = _ref.fetch,\n        fetch = _ref$fetch === void 0 ? crossFetchBinaryRange : _ref$fetch,\n        _ref$size = _ref.size,\n        size = _ref$size === void 0 ? 10000000 : _ref$size,\n        _ref$chunkSize = _ref.chunkSize,\n        chunkSize = _ref$chunkSize === void 0 ? 32768 : _ref$chunkSize,\n        _ref$aggregationTime = _ref.aggregationTime,\n        aggregationTime = _ref$aggregationTime === void 0 ? 100 : _ref$aggregationTime,\n        _ref$minimumTTL = _ref.minimumTTL,\n        minimumTTL = _ref$minimumTTL === void 0 ? 1000 : _ref$minimumTTL,\n        _ref$maxFetchSize = _ref.maxFetchSize,\n        maxFetchSize = _ref$maxFetchSize === void 0 ? chunkSize * 4 : _ref$maxFetchSize,\n        _ref$maxExtraFetch = _ref.maxExtraFetch,\n        maxExtraFetch = _ref$maxExtraFetch === void 0 ? chunkSize : _ref$maxExtraFetch;\n    (0, _classCallCheck2.default)(this, HttpRangeFetcher);\n    this.aggregator = new AggregatingFetcher({\n      fetch: fetch,\n      frequency: aggregationTime,\n      maxFetchSize: maxFetchSize,\n      maxExtraSize: maxExtraFetch\n    });\n    this.chunkSize = chunkSize;\n    this.chunkCache = new LRU({\n      maxSize: Math.floor(size / chunkSize) || 1\n    });\n    this.cacheSemantics = new CacheSemantics({\n      minimumTTL: minimumTTL\n    });\n    this.stats = new LRU({\n      maxSize: 20\n    });\n  }\n  /**\n   * Fetch a range of a remote resource.\n   * @param {string} key the resource's unique identifier, this would usually be a URL.\n   * This is passed along to the fetch callback.\n   * @param {number} [position] offset in the file at which to start fetching\n   * @param {number} [length] number of bytes to fetch, defaults to the remainder of the file\n   * @param {object} [options] request options\n   * @param {AbortSignal} [options.signal] AbortSignal object that can be used to abort the fetch\n   */\n\n\n  (0, _createClass2.default)(HttpRangeFetcher, [{\n    key: \"getRange\",\n    value: function () {\n      var _getRange = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee(key) {\n        var _this = this;\n\n        var position,\n            length,\n            options,\n            stat,\n            firstChunk,\n            lastChunk,\n            fetches,\n            _loop,\n            chunk,\n            chunkResponses,\n            chunksOffset,\n            _args = arguments;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                position = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;\n                length = _args.length > 2 ? _args[2] : undefined;\n                options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n                if (!(length === undefined)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                _context.next = 6;\n                return this.stat(key);\n\n              case 6:\n                stat = _context.sent;\n\n                if (!(stat.size === undefined)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                throw new Error(\"length not specified, and could not determine size of the remote file\");\n\n              case 9:\n                length = stat.size - position;\n\n              case 10:\n                // calculate the list of chunks involved in this fetch\n                firstChunk = Math.floor(position / this.chunkSize);\n                lastChunk = Math.floor((position + length - 1) / this.chunkSize); // fetch them all as necessary\n\n                fetches = new Array(lastChunk - firstChunk + 1);\n\n                _loop = function _loop(chunk) {\n                  fetches[chunk - firstChunk] = _this._getChunk(key, chunk, options).then(function (response) {\n                    return response && {\n                      headers: response.headers,\n                      buffer: response.buffer,\n                      chunkNumber: chunk\n                    };\n                  });\n                };\n\n                for (chunk = firstChunk; chunk <= lastChunk; chunk += 1) {\n                  _loop(chunk);\n                } // return a \"composite buffer\" that lets the array of chunks be accessed like a flat buffer\n\n\n                _context.next = 17;\n                return Promise.all(fetches);\n\n              case 17:\n                chunkResponses = _context.sent;\n                chunkResponses = chunkResponses.filter(function (r) {\n                  return !!r;\n                }); // filter out any undefined (out of range) responses\n\n                if (chunkResponses.length) {\n                  _context.next = 21;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  headers: {},\n                  buffer: Buffer.allocUnsafe(0)\n                });\n\n              case 21:\n                chunksOffset = position - chunkResponses[0].chunkNumber * this.chunkSize;\n                return _context.abrupt(\"return\", {\n                  headers: this._makeHeaders(chunkResponses[0].headers, position, position + length - 1),\n                  buffer: this._makeBuffer(chunkResponses, chunksOffset, length)\n                });\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getRange(_x) {\n        return _getRange.apply(this, arguments);\n      }\n\n      return getRange;\n    }()\n  }, {\n    key: \"_makeBuffer\",\n    value: function _makeBuffer(chunkResponses, chunksOffset, length) {\n      if (chunkResponses.length === 1) {\n        return chunkResponses[0].buffer.slice(chunksOffset, chunksOffset + length);\n      } else if (chunkResponses.length === 0) {\n        return Buffer.allocUnsafe(0);\n      } // 2 or more buffers\n\n\n      var buffers = chunkResponses.map(function (r) {\n        return r.buffer;\n      });\n      var first = buffers.shift().slice(chunksOffset);\n      var last = buffers.pop();\n      var trimEnd = first.length + buffers.reduce(function (sum, buf) {\n        return sum + buf.length;\n      }, 0) + last.length - length;\n\n      if (trimEnd < 0) {\n        trimEnd = 0;\n      }\n\n      last = last.slice(0, last.length - trimEnd);\n      return Buffer.concat([first].concat((0, _toConsumableArray2.default)(buffers), [last]));\n    }\n    /**\n     * Fetches the first few bytes of the remote file (if necessary) and uses\n     * the returned headers to populate a `fs`-like stat object.\n     *\n     * Currently, this attempts to set `size`, `mtime`, and `mtimeMs`, if\n     * the information is available from HTTP headers.\n     *\n     * @param {string} key\n     * @returns {Promise} for a stats object\n     */\n\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee2(key) {\n        var stat;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                stat = this.stats.get(key);\n\n                if (stat) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 4;\n                return this._getChunk(key, 0);\n\n              case 4:\n                stat = this.stats.get(key);\n\n                if (stat) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                throw new Error(\"failed to retrieve file size for \".concat(key));\n\n              case 7:\n                return _context2.abrupt(\"return\", stat);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stat(_x2) {\n        return _stat.apply(this, arguments);\n      }\n\n      return stat;\n    }()\n  }, {\n    key: \"_headersToStats\",\n    value: function _headersToStats(chunkResponse) {\n      var headers = chunkResponse.headers;\n      var stat = {};\n\n      if (headers['content-range']) {\n        var match = headers['content-range'].match(/\\d+-\\d+\\/(\\d+)/);\n\n        if (match) {\n          stat.size = parseInt(match[1], 10);\n          if (Number.isNaN(stat.size)) delete stat.size;\n        }\n      }\n\n      if (headers['last-modified']) {\n        stat.mtime = new Date(headers['last-modified']);\n        if (stat.mtime.toString() === 'Invalid Date') delete stat.mtime;\n\n        if (stat.mtime) {\n          stat.mtimeMs = stat.mtime.getTime();\n        }\n      }\n\n      return stat;\n    }\n  }, {\n    key: \"_makeHeaders\",\n    value: function _makeHeaders(originalHeaders, newStart, newEnd) {\n      var newHeaders = Object.assign({}, originalHeaders || {});\n      newHeaders['content-length'] = newEnd - newStart;\n      var oldContentRange = newHeaders['content-range'] || '';\n      var match = oldContentRange.match(/\\d+-\\d+\\/(\\d+)/);\n\n      if (match) {\n        newHeaders['content-range'] = \"\".concat(newStart, \"-\").concat(newEnd - 1, \"/\").concat(match[1]);\n        newHeaders['x-resource-length'] = match[1];\n      }\n\n      return newHeaders;\n    }\n  }, {\n    key: \"_getChunk\",\n    value: function () {\n      var _getChunk2 = (0, _asyncToGenerator2.default)(\n      /*#__PURE__*/\n      _regenerator.default.mark(function _callee3(key, chunkNumber, requestOptions) {\n        var _this2 = this;\n\n        var chunkKey, cachedPromise, chunk, chunkAborted, fetchStart, fetchEnd, stat, alreadyRejected, freshPromise, freshChunk;\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                chunkKey = \"\".concat(key, \"/\").concat(chunkNumber);\n                cachedPromise = this.chunkCache.get(chunkKey);\n\n                if (!cachedPromise) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                _context3.prev = 3;\n                _context3.next = 6;\n                return cachedPromise;\n\n              case 6:\n                chunk = _context3.sent;\n                _context3.next = 16;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](3);\n\n                if (!isAbortException(_context3.t0)) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                // fetch was aborted\n                chunkAborted = true;\n                _context3.next = 16;\n                break;\n\n              case 15:\n                throw _context3.t0;\n\n              case 16:\n                if (!(chunkAborted || !this.cacheSemantics.cachedChunkIsValid(chunk))) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                this._uncacheIfSame(chunkKey, cachedPromise);\n\n                return _context3.abrupt(\"return\", this._getChunk(key, chunkNumber, requestOptions));\n\n              case 19:\n                return _context3.abrupt(\"return\", chunk);\n\n              case 20:\n                fetchStart = chunkNumber * this.chunkSize;\n                fetchEnd = fetchStart + this.chunkSize; // clamp the end of the fetch to the size if we have a cached size for the file\n\n                stat = this.stats.get(key);\n\n                if (!(stat && stat.size)) {\n                  _context3.next = 27;\n                  break;\n                }\n\n                if (!(fetchStart >= stat.size)) {\n                  _context3.next = 26;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", undefined);\n\n              case 26:\n                if (fetchEnd >= stat.size) fetchEnd = stat.size;\n\n              case 27:\n                alreadyRejected = false;\n                freshPromise = this.aggregator.fetch(key, fetchStart, fetchEnd, requestOptions).catch(function (err) {\n                  // if the request fails, remove its promise\n                  // from the cache and keep the error\n                  alreadyRejected = true;\n\n                  _this2._uncacheIfSame(chunkKey, freshPromise);\n\n                  throw err;\n                });\n                if (!alreadyRejected) this.chunkCache.set(chunkKey, freshPromise);\n                _context3.next = 32;\n                return freshPromise;\n\n              case 32:\n                freshChunk = _context3.sent;\n                // gather the stats for the file from the headers\n                this.stats.set(key, this._headersToStats(freshChunk)); // remove the promise from the cache\n                // if it turns out not to be cacheable. this is\n                // done after the fact because we want multiple requests\n                // for the same chunk to reuse the same cached promise\n\n                if (!this.cacheSemantics.chunkIsCacheable(freshChunk)) {\n                  this._uncacheIfSame(chunkKey, freshPromise);\n                }\n\n                return _context3.abrupt(\"return\", freshChunk);\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 9]]);\n      }));\n\n      function _getChunk(_x3, _x4, _x5) {\n        return _getChunk2.apply(this, arguments);\n      }\n\n      return _getChunk;\n    }() // delete a promise from the cache if it is still in there.\n    // need to check if it is still the same because it might\n    // have been overwritten sometime while the promise was in flight\n\n  }, {\n    key: \"_uncacheIfSame\",\n    value: function _uncacheIfSame(key, cachedPromise) {\n      if (this.chunkCache.get(key) === cachedPromise) {\n        this.chunkCache.delete(key);\n      }\n    }\n    /**\n     * Throw away all cached data, resetting the cache.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.stats.clear();\n      this.chunkCache.clear();\n    }\n  }]);\n  return HttpRangeFetcher;\n}();\n\nmodule.exports = HttpRangeFetcher;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/http-range-fetcher/dist/httpRangeFetcher.js?");

/***/ }),

/***/ "./node_modules/http-range-fetcher/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/http-range-fetcher/dist/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar HttpRangeFetcher = __webpack_require__(/*! ./httpRangeFetcher */ \"./node_modules/http-range-fetcher/dist/httpRangeFetcher.js\");\n\nmodule.exports = {\n  HttpRangeFetcher: HttpRangeFetcher\n};\n\n//# sourceURL=webpack:///./node_modules/http-range-fetcher/dist/index.js?");

/***/ }),

/***/ "./node_modules/http-range-fetcher/node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/http-range-fetcher/node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __root__ = (function (root) {\nfunction F() { this.fetch = false; }\nF.prototype = root;\nreturn new F();\n})(typeof self !== 'undefined' ? self : this);\n(function(self) {\n\n(function(self) {\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    };\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue+','+value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push(name); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) { items.push(value); });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) { items.push([name, value]); });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=');\n        var name = split.shift().replace(/\\+/g, ' ');\n        var value = split.join('=').replace(/\\+/g, ' ');\n        form.append(decodeURIComponent(name), decodeURIComponent(value));\n      }\n    });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  };\n  self.fetch.polyfill = true;\n})(typeof self !== 'undefined' ? self : this);\n}).call(__root__, void(0));\nvar fetch = __root__.fetch;\nvar Response = fetch.Response = __root__.Response;\nvar Request = fetch.Request = __root__.Request;\nvar Headers = fetch.Headers = __root__.Headers;\nif ( true && module.exports) {\nmodule.exports = fetch;\n// Needed for TypeScript consumers without esModuleInterop.\nmodule.exports.default = fetch;\n}\n\n\n//# sourceURL=webpack:///./node_modules/http-range-fetcher/node_modules/cross-fetch/dist/browser-ponyfill.js?");

/***/ }),

/***/ "./node_modules/object.entries-ponyfill/entries.js":
/*!*********************************************************!*\
  !*** ./node_modules/object.entries-ponyfill/entries.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar has = function (obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop) }\nvar isEnumerable = function (obj, prop) {\n  return Object.prototype.propertyIsEnumerable.call(obj, prop)\n}\n\nfunction entries (obj) {\n  if (obj == null) {\n    throw new TypeError('Cannot convert undefined or null to object')\n  }\n  var pairs = []\n  for (var key in obj) {\n    if (has(obj, key) && isEnumerable(obj, key)) {\n      pairs.push([key, obj[key]])\n    }\n  }\n  return pairs\n}\n\nmodule.exports = entries\n\n\n//# sourceURL=webpack:///./node_modules/object.entries-ponyfill/entries.js?");

/***/ }),

/***/ "./node_modules/object.entries-ponyfill/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/object.entries-ponyfill/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = typeof Object.entries === 'function' ? Object.entries : __webpack_require__(/*! ./entries */ \"./node_modules/object.entries-ponyfill/entries.js\")\n\n\n//# sourceURL=webpack:///./node_modules/object.entries-ponyfill/index.js?");

/***/ }),

/***/ "./node_modules/quick-lru/index.js":
/*!*****************************************!*\
  !*** ./node_modules/quick-lru/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar QuickLRU = function () {\n\tfunction QuickLRU() {\n\t\tvar options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n\t\t_classCallCheck(this, QuickLRU);\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t_createClass(QuickLRU, [{\n\t\tkey: '_set',\n\t\tvalue: function _set(key, value) {\n\t\t\tthis.cache.set(key, value);\n\t\t\tthis._size++;\n\n\t\t\tif (this._size >= this.maxSize) {\n\t\t\t\tthis._size = 0;\n\t\t\t\tthis.oldCache = this.cache;\n\t\t\t\tthis.cache = new Map();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'get',\n\t\tvalue: function get(key) {\n\t\t\tif (this.cache.has(key)) {\n\t\t\t\treturn this.cache.get(key);\n\t\t\t}\n\n\t\t\tif (this.oldCache.has(key)) {\n\t\t\t\tvar value = this.oldCache.get(key);\n\t\t\t\tthis._set(key, value);\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'set',\n\t\tvalue: function set(key, value) {\n\t\t\tif (this.cache.has(key)) {\n\t\t\t\tthis.cache.set(key, value);\n\t\t\t} else {\n\t\t\t\tthis._set(key, value);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: 'has',\n\t\tvalue: function has(key) {\n\t\t\treturn this.cache.has(key) || this.oldCache.has(key);\n\t\t}\n\t}, {\n\t\tkey: 'peek',\n\t\tvalue: function peek(key) {\n\t\t\tif (this.cache.has(key)) {\n\t\t\t\treturn this.cache.get(key);\n\t\t\t}\n\n\t\t\tif (this.oldCache.has(key)) {\n\t\t\t\treturn this.oldCache.get(key);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'delete',\n\t\tvalue: function _delete(key) {\n\t\t\tvar deleted = this.cache.delete(key);\n\t\t\tif (deleted) {\n\t\t\t\tthis._size--;\n\t\t\t}\n\n\t\t\treturn this.oldCache.delete(key) || deleted;\n\t\t}\n\t}, {\n\t\tkey: 'clear',\n\t\tvalue: function clear() {\n\t\t\tthis.cache.clear();\n\t\t\tthis.oldCache.clear();\n\t\t\tthis._size = 0;\n\t\t}\n\t}, {\n\t\tkey: 'keys',\n\t\tvalue: /*#__PURE__*/regeneratorRuntime.mark(function keys() {\n\t\t\tvar _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, key;\n\n\t\t\treturn regeneratorRuntime.wrap(function keys$(_context) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tswitch (_context.prev = _context.next) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t_iteratorNormalCompletion = true;\n\t\t\t\t\t\t\t_didIteratorError = false;\n\t\t\t\t\t\t\t_iteratorError = undefined;\n\t\t\t\t\t\t\t_context.prev = 3;\n\t\t\t\t\t\t\t_iterator = this[Symbol.iterator]();\n\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tif (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n\t\t\t\t\t\t\t\t_context.next = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_step$value = _slicedToArray(_step.value, 1), key = _step$value[0];\n\t\t\t\t\t\t\t_context.next = 9;\n\t\t\t\t\t\t\treturn key;\n\n\t\t\t\t\t\tcase 9:\n\t\t\t\t\t\t\t_iteratorNormalCompletion = true;\n\t\t\t\t\t\t\t_context.next = 5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 12:\n\t\t\t\t\t\t\t_context.next = 18;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 14:\n\t\t\t\t\t\t\t_context.prev = 14;\n\t\t\t\t\t\t\t_context.t0 = _context['catch'](3);\n\t\t\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t\t\t_iteratorError = _context.t0;\n\n\t\t\t\t\t\tcase 18:\n\t\t\t\t\t\t\t_context.prev = 18;\n\t\t\t\t\t\t\t_context.prev = 19;\n\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase 21:\n\t\t\t\t\t\t\t_context.prev = 21;\n\n\t\t\t\t\t\t\tif (!_didIteratorError) {\n\t\t\t\t\t\t\t\t_context.next = 24;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow _iteratorError;\n\n\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\treturn _context.finish(21);\n\n\t\t\t\t\t\tcase 25:\n\t\t\t\t\t\t\treturn _context.finish(18);\n\n\t\t\t\t\t\tcase 26:\n\t\t\t\t\t\tcase 'end':\n\t\t\t\t\t\t\treturn _context.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, keys, this, [[3, 14, 18, 26], [19,, 21, 25]]);\n\t\t})\n\t}, {\n\t\tkey: 'values',\n\t\tvalue: /*#__PURE__*/regeneratorRuntime.mark(function values() {\n\t\t\tvar _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _step2$value, value;\n\n\t\t\treturn regeneratorRuntime.wrap(function values$(_context2) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tswitch (_context2.prev = _context2.next) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t_iteratorNormalCompletion2 = true;\n\t\t\t\t\t\t\t_didIteratorError2 = false;\n\t\t\t\t\t\t\t_iteratorError2 = undefined;\n\t\t\t\t\t\t\t_context2.prev = 3;\n\t\t\t\t\t\t\t_iterator2 = this[Symbol.iterator]();\n\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tif (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n\t\t\t\t\t\t\t\t_context2.next = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_step2$value = _slicedToArray(_step2.value, 2), value = _step2$value[1];\n\t\t\t\t\t\t\t_context2.next = 9;\n\t\t\t\t\t\t\treturn value;\n\n\t\t\t\t\t\tcase 9:\n\t\t\t\t\t\t\t_iteratorNormalCompletion2 = true;\n\t\t\t\t\t\t\t_context2.next = 5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 12:\n\t\t\t\t\t\t\t_context2.next = 18;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 14:\n\t\t\t\t\t\t\t_context2.prev = 14;\n\t\t\t\t\t\t\t_context2.t0 = _context2['catch'](3);\n\t\t\t\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t\t\t\t_iteratorError2 = _context2.t0;\n\n\t\t\t\t\t\tcase 18:\n\t\t\t\t\t\t\t_context2.prev = 18;\n\t\t\t\t\t\t\t_context2.prev = 19;\n\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase 21:\n\t\t\t\t\t\t\t_context2.prev = 21;\n\n\t\t\t\t\t\t\tif (!_didIteratorError2) {\n\t\t\t\t\t\t\t\t_context2.next = 24;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow _iteratorError2;\n\n\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\treturn _context2.finish(21);\n\n\t\t\t\t\t\tcase 25:\n\t\t\t\t\t\t\treturn _context2.finish(18);\n\n\t\t\t\t\t\tcase 26:\n\t\t\t\t\t\tcase 'end':\n\t\t\t\t\t\t\treturn _context2.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, values, this, [[3, 14, 18, 26], [19,, 21, 25]]);\n\t\t})\n\t}, {\n\t\tkey: Symbol.iterator,\n\t\tvalue: /*#__PURE__*/regeneratorRuntime.mark(function value() {\n\t\t\tvar _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, item, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _item, _item2, key;\n\n\t\t\treturn regeneratorRuntime.wrap(function value$(_context3) {\n\t\t\t\twhile (1) {\n\t\t\t\t\tswitch (_context3.prev = _context3.next) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t_iteratorNormalCompletion3 = true;\n\t\t\t\t\t\t\t_didIteratorError3 = false;\n\t\t\t\t\t\t\t_iteratorError3 = undefined;\n\t\t\t\t\t\t\t_context3.prev = 3;\n\t\t\t\t\t\t\t_iterator3 = this.cache[Symbol.iterator]();\n\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tif (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n\t\t\t\t\t\t\t\t_context3.next = 12;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\titem = _step3.value;\n\t\t\t\t\t\t\t_context3.next = 9;\n\t\t\t\t\t\t\treturn item;\n\n\t\t\t\t\t\tcase 9:\n\t\t\t\t\t\t\t_iteratorNormalCompletion3 = true;\n\t\t\t\t\t\t\t_context3.next = 5;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 12:\n\t\t\t\t\t\t\t_context3.next = 18;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 14:\n\t\t\t\t\t\t\t_context3.prev = 14;\n\t\t\t\t\t\t\t_context3.t0 = _context3['catch'](3);\n\t\t\t\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t\t\t\t_iteratorError3 = _context3.t0;\n\n\t\t\t\t\t\tcase 18:\n\t\t\t\t\t\t\t_context3.prev = 18;\n\t\t\t\t\t\t\t_context3.prev = 19;\n\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase 21:\n\t\t\t\t\t\t\t_context3.prev = 21;\n\n\t\t\t\t\t\t\tif (!_didIteratorError3) {\n\t\t\t\t\t\t\t\t_context3.next = 24;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow _iteratorError3;\n\n\t\t\t\t\t\tcase 24:\n\t\t\t\t\t\t\treturn _context3.finish(21);\n\n\t\t\t\t\t\tcase 25:\n\t\t\t\t\t\t\treturn _context3.finish(18);\n\n\t\t\t\t\t\tcase 26:\n\t\t\t\t\t\t\t_iteratorNormalCompletion4 = true;\n\t\t\t\t\t\t\t_didIteratorError4 = false;\n\t\t\t\t\t\t\t_iteratorError4 = undefined;\n\t\t\t\t\t\t\t_context3.prev = 29;\n\t\t\t\t\t\t\t_iterator4 = this.oldCache[Symbol.iterator]();\n\n\t\t\t\t\t\tcase 31:\n\t\t\t\t\t\t\tif (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n\t\t\t\t\t\t\t\t_context3.next = 40;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_item = _step4.value;\n\t\t\t\t\t\t\t_item2 = _slicedToArray(_item, 1), key = _item2[0];\n\n\t\t\t\t\t\t\tif (this.cache.has(key)) {\n\t\t\t\t\t\t\t\t_context3.next = 37;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_context3.next = 37;\n\t\t\t\t\t\t\treturn _item;\n\n\t\t\t\t\t\tcase 37:\n\t\t\t\t\t\t\t_iteratorNormalCompletion4 = true;\n\t\t\t\t\t\t\t_context3.next = 31;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 40:\n\t\t\t\t\t\t\t_context3.next = 46;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 42:\n\t\t\t\t\t\t\t_context3.prev = 42;\n\t\t\t\t\t\t\t_context3.t1 = _context3['catch'](29);\n\t\t\t\t\t\t\t_didIteratorError4 = true;\n\t\t\t\t\t\t\t_iteratorError4 = _context3.t1;\n\n\t\t\t\t\t\tcase 46:\n\t\t\t\t\t\t\t_context3.prev = 46;\n\t\t\t\t\t\t\t_context3.prev = 47;\n\n\t\t\t\t\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t\t\t\t\t_iterator4.return();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase 49:\n\t\t\t\t\t\t\t_context3.prev = 49;\n\n\t\t\t\t\t\t\tif (!_didIteratorError4) {\n\t\t\t\t\t\t\t\t_context3.next = 52;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow _iteratorError4;\n\n\t\t\t\t\t\tcase 52:\n\t\t\t\t\t\t\treturn _context3.finish(49);\n\n\t\t\t\t\t\tcase 53:\n\t\t\t\t\t\t\treturn _context3.finish(46);\n\n\t\t\t\t\t\tcase 54:\n\t\t\t\t\t\tcase 'end':\n\t\t\t\t\t\t\treturn _context3.stop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, value, this, [[3, 14, 18, 26], [19,, 21, 25], [29, 42, 46, 54], [47,, 49, 53]]);\n\t\t})\n\t}, {\n\t\tkey: 'size',\n\t\tget: function get() {\n\t\t\tvar oldCacheSize = 0;\n\t\t\tvar _iteratorNormalCompletion5 = true;\n\t\t\tvar _didIteratorError5 = false;\n\t\t\tvar _iteratorError5 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator5 = this.oldCache.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n\t\t\t\t\tvar key = _step5.value;\n\n\t\t\t\t\tif (!this.cache.has(key)) {\n\t\t\t\t\t\toldCacheSize++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError5 = true;\n\t\t\t\t_iteratorError5 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion5 && _iterator5.return) {\n\t\t\t\t\t\t_iterator5.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError5) {\n\t\t\t\t\t\tthrow _iteratorError5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this._size + oldCacheSize;\n\t\t}\n\t}]);\n\n\treturn QuickLRU;\n}();\n\nmodule.exports = QuickLRU;\n\n//# sourceURL=webpack:///./node_modules/quick-lru/index.js?");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n\n//# sourceURL=webpack:///./node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "./node_modules/tenacious-fetch/dist/tenacious-fetch.m.js":
/*!****************************************************************!*\
  !*** ./node_modules/tenacious-fetch/dist/tenacious-fetch.m.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction e(e,r,n){return new Promise(function(o,i){!function e(r,n,u){var f=n.retryStatus;(0,n.fetcher)(r,n).then(function(s){if(f.includes(s.status))if(u>0){var c=t(n,--u);n.onRetry&&\"function\"==typeof n.onRetry&&n.onRetry({retriesLeft:u,retryDelay:c,response:s}),setTimeout(function(){return e(r,n,u)},c)}else i(s);else o(s)}).catch(function(o){if(u>0){var f=t(n,--u);n.onRetry&&\"function\"==typeof n.onRetry&&n.onRetry({retriesLeft:u,retryDelay:f,response:o}),setTimeout(function(){return e(r,n,u)},f)}else i(o)})}(r,n,e)})}function t(e,t){var r=e.retryDelay,n=e.factor,o=e.retries;return n&&\"number\"==typeof n&&Number.isInteger(n)?function(e,t){return Math.pow(e,t)}(n,o-t):r*(o-t)}var r=!1;try{r=window&&window.fetch}catch(e){}/* harmony default export */ __webpack_exports__[\"default\"] = (function(t,n){if(void 0===t&&(t=\"\"),void 0===n&&(n={}),!(n=Object.assign({retries:1,retryDelay:1e3,retryStatus:[],fetcher:r,timeout:void 0},n)).fetcher||\"function\"!=typeof n.fetcher)throw new Error(\"tenacious-fetch: No fetch implementation found. Provide a valid fetch implementation via the fetcher configuration property.\");\"string\"!=typeof n.retryStatus&&\"number\"!=typeof n.retryStatus||(n.retryStatus=[Number.parseInt(n.retryStatus)]);var o=n.timeout;return o&&Number.isInteger(o)?Promise.race([e(n.retries,t,n),new Promise(function(e,t){return setTimeout(function(){return t(new Error(\"tenacious-fetch: Request took longer than timeout of \"+o+\" ms.\"))},o)})]):e(n.retries,t,n)});;\n//# sourceMappingURL=tenacious-fetch.m.js.map\n\n\n//# sourceURL=webpack:///./node_modules/tenacious-fetch/dist/tenacious-fetch.m.js?");

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status === undefined ? 200 : options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n//# sourceURL=webpack:///./node_modules/whatwg-fetch/fetch.js?");

/***/ })

}]);